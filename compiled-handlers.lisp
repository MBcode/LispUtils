;compiled-handlers.lisp from: quicklisp/software/km-2-5-33 directory, hand edited to compile on old machines by mike.bobak@gmail
;http://www.cs.utexas.edu/users/mfkb/RKF/km.html
(unless (find-package :km) (make-package :km :use '(:common-lisp)))
(in-package :km)

;;; File: compiled-handlers.lisp
;;; Author: MACHINE GENERATED FILE, generated by compiler.lisp (author Adam Farquahar)
;;; This file was generated by (write-compiled-handlers) in compiler.lisp.
;;; This partially flattens the code assigned to *km-handler-list*, which results in
;;; 10%-30% faster execution (10%-30%) at run-time. Loading of this file is optional, 
;;; KM will be slower if it's not loaded. For the legible, unflattened source of this
;;; flattened code, see the file interpreter.lisp.
;;;
;;; NOTE: manually insert the line after compiled-km-handler-function for KM release:
;;;
;;; (defun compiled-km-handler-function (f-mode x)
;;;   #+harlequin-pc-lisp (declare (optimize (debug 0)))     ; patch for Lispworks from Francis Leboutte [1]
;;;  (block km-handler
;;;	...
;;;
;;; ==================== START OF MACHINE-GENERATED FILE ====================
;Why couldn't we have gotten the code that generates this? W/o it I had to hand edit this:
;  well it could have been automated, but not that many   ..we'll see where this goes, might feed into some other updates/?
;   there is a write-compiled-handlers but don't think is or should be called

;KM: km_2-5-45.lisp &quicklisp: :KM both can crap out on: compiled-handlers.lisp, so starting to rework the file;need2get around return-from block ..
;   pulled out 34 handler blocks of code, and made seperate functions, it compiles, but need2test that ret vals all passed up properly
;   This finally allows a version of KM to be used on an old 32bit PPC Linux box I have sitting around.

;I can get 'tax' of Thing, but when components/core classes are loaded via nlp/lcc.lisp then I see similar probs, so dbg here

;If need be can rename the main/original block, but shouldn't be a problem

(setq *compile-handlers* t)

(defun h--the (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (eql xrrl '|of|)
                    (when (consp xrrr)
                      (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                        (when (eql xrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (fmode0 _target slot frameadd)
                                                 (declare (ignore _target))
                                                 (cond ((structured-slotp slot)
                                                        (follow-multidepth-path (km-int frameadd :fail-mode fmode0) slot '*
                                                          :fail-mode fmode0))
                                                       ((pathp slot)
                                                        (let ((eval-slot (km-unique-int slot :fail-mode 'error)))
                                                          (km-int `(|the| ,eval-slot |of| ,frameadd) :fail-mode fmode0)))
                                                       (t
                                                        (let* ((fmode
                                                                (cond ((built-in-aggregation-slot slot) 'fail) (t fmode0)))
                                                               (frames
                                                                (cond ((every #'is-simple-km-term (val-to-vals frameadd))
                                                                       (remove-dup-instances (val-to-vals frameadd)))
                                                                      (t
                                                                       (km-int frameadd
                                                                         :fail-mode fmode
                                                                         :check-for-looping nil)))))
                                                          (cond ((= *depth* 1)
                                                                 (setq *last-question*
                                                                       `(|the| ,slot |of| ,(vals-to-val frames)))))
                                                          (cond ((not (equal frames (val-to-vals frameadd)))
                                                                 (remove-if-not #'is-km-term
                                                                                (km-int
                                                                                   `(|the|
                                                                                     ,slot
                                                                                     |of|
                                                                                     ,(vals-to-val frames))
                                                                                  :fail-mode fmode)))
                                                                (t
                                                                 (remove-if-not #'is-km-term
                                                                                (km-multi-slotvals frames slot
                                                                                  :fail-mode fmode))))))))
                                             f-mode target xrl xrrrl)
                                    '(|the| ?slot |of| ?frameadd)))))))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (when (eql xrrrl '|of|)
                        (when (consp xrrrr)
                          (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                            (when (eql xrrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (fmode0 target class slot frameadd)
                                                     (cond ((structured-slotp slot)
                                                            (follow-multidepth-path
                                                               (km-int frameadd
                                                                 :fail-mode fmode0
                                                                 :target target
                                                                 :rewritep t)
                                                               slot class
                                                              :fail-mode fmode0))
                                                           ((pathp slot)
                                                            (let ((eval-slot (km-unique-int slot :fail-mode 'error)))
                                                              (km-int `(|the| ,class ,eval-slot |of| ,frameadd)
                                                                :fail-mode fmode0
                                                                :target target
                                                                :rewritep t)))
                                                           (t
                                                            (let* ((fmode
                                                                    (cond ((built-in-aggregation-slot slot) 'fail)
                                                                          (t fmode0))))
                                                              (vals-in-class (km-int `(|the| ,slot |of| ,frameadd)
                                                                               :fail-mode fmode
                                                                               :target target
                                                                               :rewritep t)
                                                                             class)))))
                                                 f-mode target xrl xrrl xrrrrl)
                                        '(|the| ?class ?slot |of| ?frameadd)))))))))
                  (when (eql xrrl '|with|)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target frame slotsvals)
                                           (declare (ignore fmode target))
                                           (let ((answer (km-int `(|every| ,frame |with| ,@slotsvals))))
                                             (cond ((null answer)
                                                    (report-error 'user-error "No values found for expression ~a!~%"
                                                                  `(|the| ,frame |with| ,@slotsvals)))
                                                   ((not (singletonp answer))
                                                    (report-error 'user-error
                                                                  "Expected a single value for expression ~a, but found multiple values ~a!~%"
                                                                  `(|the| ,frame |with| ,@slotsvals) answer))
                                                   (t answer))))
                                       f-mode target xrl xrrr)
                              '(|the| ?frame |with| &rest)))))))
          (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (fmode target frame)
                                   (declare (ignore fmode target))
                                   (let ((answer (km-int `(|every| ,frame))))
                                     (cond ((null answer)
                                            (report-error 'user-error "No values found for expression ~a!~%"
                                                          `(|the| ,frame)))
                                           ((not (singletonp answer))
                                            (report-error 'user-error
                                                          "Expected a single value for expression ~a, but found multiple values ~a!~%"
                                                          `(|the| ,frame) answer))
                                           (t answer))))
                               f-mode target xrl)
                      '(|the| ?frame))))))
))
(defun h--a (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (_fmode target class)
                                   (declare (ignore _fmode))
                                   (list (create-instance class nil :target target)))
                               f-mode target xrl)
                      '(|a| ?class))))
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (eql xrrl '|called|)
                    (when (consp xrrr)
                      (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                        (or (when (eql xrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (_fmode target class tag)
                                                     (declare (ignore _fmode))
                                                     (km-setq '*are-some-tags* t)
                                                     (cond ((km-tagp tag)
                                                            (list (create-instance class `((|called| ,(val-to-vals tag)))
                                                                    :target target)))
                                                           (t
                                                            (report-error 'user-error
                                                                          "~a~%    - The tag `~a' must be an atom or a constraint!"
                                                                          `(|a| ,class |called| ,tag) tag))))
                                                 f-mode target xrl xrrrl)
                                        '(|a| ?class |called| ?tag))))
                            (when (consp xrrrr)
                              (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                                (when (eql xrrrrl '|with|)
                                  (return-from km-handler
                                    (values (funcall #'(lambda (_fmode target class tag slotsvals)
                                                         (declare (ignore _fmode))
                                                         (km-setq '*are-some-tags* t)
                                                         (cond ((not (km-tagp tag))
                                                                (report-error 'user-error
                                                                              "~a~%   - The tag `~a' must be an atom or a constraint!"
                                                                              `(|a| ,class |called| ,tag |with|
                                                                                ,@slotsvals)
                                                                              tag))
                                                               ((are-slotsvals slotsvals)
                                                                (let ((instance
                                                                       (create-instance class
                                                                                        (cons
                                                                                         `(|called| ,(val-to-vals tag))
                                                                                         (convert-comments-to-internal-form
                                                                                          slotsvals))
                                                                         :target target)))
                                                                  (cond ((am-in-prototype-mode)
                                                                         (km-int '(|evaluate-paths|))))
                                                                  (list instance)))))
                                                     f-mode target xrl xrrrl xrrrrr)
                                            '(|a| ?class |called| ?tag |with| &rest))))))))))
                  (when (eql xrrl '|uniquely-called|)
                    (when (consp xrrr)
                      (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                        (or (when (eql xrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (_fmode target class tag)
                                                     (declare (ignore _fmode))
                                                     (km-setq '*are-some-constraints* t)
                                                     (km-setq '*are-some-tags* t)
                                                     (cond ((km-tagp tag)
                                                            (list (create-instance class
                                                                                   `((|uniquely-called|
                                                                                      ,(val-to-vals tag)))
                                                                    :target target)))
                                                           (t
                                                            (report-error 'user-error
                                                                          "~a~%    - The tag `~a' must be an atom or a constraint!"
                                                                          `(|a| ,class |uniquely-called| ,tag) tag))))
                                                 f-mode target xrl xrrrl)
                                        '(|a| ?class |uniquely-called| ?tag))))
                            (when (consp xrrrr)
                              (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                                (when (eql xrrrrl '|with|)
                                  (return-from km-handler
                                    (values (funcall #'(lambda (_fmode target class tag slotsvals)
                                                         (declare (ignore _fmode))
                                                         (km-setq '*are-some-constraints* t)
                                                         (km-setq '*are-some-tags* t)
                                                         (cond ((not (km-tagp tag))
                                                                (report-error 'user-error
                                                                              "~a~%   - The tag `~a' must be an atom or a constraint!"
                                                                              `(|a| ,class |uniquely-called| ,tag |with|
                                                                                ,@slotsvals)
                                                                              tag))
                                                               ((are-slotsvals slotsvals)
                                                                (let ((instance
                                                                       (create-instance class
                                                                                        (cons
                                                                                         `(|uniquely-called|
                                                                                           ,(val-to-vals tag))
                                                                                         (convert-comments-to-internal-form
                                                                                          slotsvals))
                                                                         :target target)))
                                                                  (cond ((am-in-prototype-mode)
                                                                         (km-int '(|evaluate-paths|))))
                                                                  (list instance)))))
                                                     f-mode target xrl xrrrl xrrrrr)
                                            '(|a| ?class |uniquely-called| ?tag |with| &rest))))))))))
                  (when (eql xrrl '|with|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode target class slotsvals)
                                           (declare (ignore _fmode))
                                           (cond ((are-slotsvals slotsvals)
                                                  (let ((instance
                                                         (create-instance class
                                                                          (convert-comments-to-internal-form slotsvals)
                                                           :target target)))
                                                    (cond ((am-in-prototype-mode) (km-int '(|evaluate-paths|))))
                                                    (list instance)))))
                                       f-mode target xrl xrrr)
                              '(|a| ?class |with| &rest)))))))))
  ))
(defun h--a-prototype (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (fmode target class)
                                   (km-int `(|a-prototype| ,class |with|) :fail-mode fmode :target target :rewritep t))
                               f-mode target xrl)
                      '(|a-prototype| ?class))))
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrl '|with|)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target class slotsvals)
                                       (declare (ignore _fmode _target))
                                       (cond ((am-in-local-situation)
                                              (report-error 'user-error
                                                            "Can't enter prototype mode when in a Situation!~%"))
                                             ((am-in-local-theory)
                                              (report-error 'user-error "Can't enter prototype mode when in a Theory!~%"))
                                             ((am-in-prototype-mode)
                                              (report-error 'user-error
                                                            "~a~%Attempt to enter prototype mode while already in prototype mode (not allowed)!~%Perhaps you are missing an (end-prototype)?"
                                                            `(|a-prototype| ,class |with| ,@slotsvals)))
                                             ((are-slotsvals slotsvals)
                                              (new-context)
                                              (km-setq '*curr-prototype*
                                                       (create-instance class
                                                                        `((|prototype-of| (,class))
                                                                          ,(cond (slotsvals
                                                                                  `(|prototype-scope|
                                                                                    ((|the-class|
                                                                                      ,class
                                                                                      |with|
                                                                                      ,@slotsvals))))
                                                                                 (t `(|prototype-scope| (,class))))
                                                                          ,@slotsvals)
                                                         :prefix-string *proto-marker-string*
                                                         :bind-selfp nil))
                                              (add-val *curr-prototype* '|prototype-participants| *curr-prototype*)
                                              (km-setq '*are-some-prototypes* t)
                                              (cond ((null slotsvals)
                                                     (add-to-prototype-definition *curr-prototype*
                                                       `(|a-prototoype| ,class)))
                                                    (t
                                                     (add-to-prototype-definition *curr-prototype*
                                                       `(|a-prototype| ,class |with| ,@slotsvals))))
                                              (list *curr-prototype*))))
                                   f-mode target xrl xrrr)
                          '(|a-prototype| ?class |with| &rest))))))))
  ))
(defun h--clone (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (eql xrr 'nil)
        (return-from km-handler
          (values (funcall #'(lambda (_fmode _target expr)
                               (declare (ignore _fmode _target))
                               (let ((source (km-unique-int expr :fail-mode 'error)))
                                 (cond (source (list (clone source))))))
                           f-mode target xrl)
                  '(|clone| ?expr)))))
  ))
(defun h--must-be-a (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (_fmode _target _class)
                                   (declare (ignore _fmode _target _class))
                                   (note-are-constraints)
                                   nil)
                               f-mode target xrl)
                      '(|must-be-a| ?class))))
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrl '|with|)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target _class slotsvals)
                                       (declare (ignore _fmode _target _class))
                                       (are-slotsvals slotsvals)
                                       (note-are-constraints)
                                       nil)
                                   f-mode target xrl xrrr)
                          '(|must-be-a| ?class |with| &rest))))))))
  ))
(defun h--every (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (eql xrrl '|has|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target cexpr slotsvals)
                                           (declare (ignore _fmode _target))
                                           (let ((class (km-unique-int cexpr :fail-mode 'error)))
                                             (cond ((not (kb-objectp class))
                                                    (report-error 'user-error
                                                                  "~a~%~a isn't/doesn't evaluate to a class name.~%"
                                                                  `(|every| ,cexpr |has| ,@slotsvals) cexpr))
                                                   ((are-slotsvals slotsvals)
                                                    (let* ((slotsvals00
                                                            (cond (*record-sources*
                                                                   (annotate-slotsvals slotsvals (make-source class)))
                                                                  (t slotsvals)))
                                                           (slotsvals0 (convert-comments-to-internal-form slotsvals00)))
                                                      (add-slotsvals class slotsvals0
                                                        :facet 'member-properties
                                                        :install-inversesp nil))
                                                    (cond ((and (assoc '|assertions| slotsvals)
                                                                (not (member class *classes-using-assertions-slot*)))
                                                           (km-setq '*classes-using-assertions-slot*
                                                                    (cons class *classes-using-assertions-slot*))))
                                                    (mapc #'un-done (all-instances class))
                                                    (list class)))))
                                       f-mode target xrl xrrr)
                              '(|every| ?cexpr |has| &rest))))
                  (when (eql xrrl '|also-has|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target cexpr slotsvals)
                                           (declare (ignore _fmode _target))
                                           (let ((class (km-unique-int cexpr :fail-mode 'error)))
                                             (cond ((not (kb-objectp class))
                                                    (report-error 'user-error
                                                                  "~a~%~a isn't/doesn't evaluate to a class name.~%"
                                                                  `(|every| ,cexpr |also-has| ,@slotsvals) cexpr))
                                                   ((are-slotsvals slotsvals)
                                                    (let* ((slotsvals00
                                                            (cond (*record-sources*
                                                                   (annotate-slotsvals slotsvals (make-source class)))
                                                                  (t slotsvals)))
                                                           (slotsvals0 (convert-comments-to-internal-form slotsvals00)))
                                                      (add-slotsvals class slotsvals0
                                                        :facet 'member-properties
                                                        :install-inversesp nil
                                                        :combine-values-by 'appending))
                                                    (cond ((and (assoc '|assertions| slotsvals)
                                                                (not (member class *classes-using-assertions-slot*)))
                                                           (km-setq '*classes-using-assertions-slot*
                                                                    (cons class *classes-using-assertions-slot*))))
                                                    (mapc #'un-done (all-instances class))
                                                    (list class)))))
                                       f-mode target xrl xrrr)
                              '(|every| ?cexpr |also-has| &rest))))
                  (when (eql xrrl '|now-has|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target cexpr slotsvals)
                                           (declare (ignore _fmode _target))
                                           (let ((class (km-unique-int cexpr :fail-mode 'error)))
                                             (cond ((not (kb-objectp class))
                                                    (report-error 'user-error
                                                                  "~a~%~a isn't/doesn't evaluate to a class name.~%"
                                                                  `(|every| ,cexpr |now-has| ,@slotsvals) cexpr))
                                                   ((are-slotsvals slotsvals)
                                                    (let* ((slotsvals00
                                                            (cond (*record-sources*
                                                                   (annotate-slotsvals slotsvals (make-source class)))
                                                                  (t slotsvals)))
                                                           (slotsvals0 (convert-comments-to-internal-form slotsvals00)))
                                                      (add-slotsvals class slotsvals0
                                                        :facet 'member-properties
                                                        :install-inversesp nil
                                                        :combine-values-by 'overwriting))
                                                    (cond ((and (assoc '|assertions| slotsvals)
                                                                (not (member class *classes-using-assertions-slot*)))
                                                           (km-setq '*classes-using-assertions-slot*
                                                                    (cons class *classes-using-assertions-slot*))))
                                                    (mapc #'un-done (all-instances class))
                                                    (list class)))))
                                       f-mode target xrl xrrr)
                              '(|every| ?cexpr |now-has| &rest))))
                  (when (eql xrrl '|also-hasnt|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                           (declare (ignore _fmode _target))
                                           (report-error 'user-error
                                                         "~a:~%Can't use also-hasnt with an \"every\" expression (can only use it with instances, not classes)~%"
                                                         `(|every| ,instance-expr |also-hasnt| ,@slotsvals)))
                                       f-mode target xrl xrrr)
                              '(|every| ?instance-expr |also-hasnt| &rest))))
                  (when (eql xrrl '|with|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target frame slotsvals)
                                           (declare (ignore _fmode _target))
                                           (cond ((are-slotsvals slotsvals)
                                                  (let ((existential-expr
                                                         (cond ((and (null slotsvals) (pathp frame))
                                                                (path-to-existential-expr frame))
                                                               (t `(|a| ,frame |with| ,@slotsvals)))))
                                                    (find-subsumees-on-object-stack existential-expr)))))
                                       f-mode target xrl xrrr)
                              '(|every| ?frame |with| &rest))))
                  (when (eql xrrl '|has-definition|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target cexpr slotsvals)
                                           (declare (ignore _fmode _target))
                                           (let ((class (km-unique-int cexpr :fail-mode 'error)))
                                             (cond ((not (kb-objectp class))
                                                    (report-error 'user-error
                                                                  "~a~%~a isn't/doesn't evaluate to a class name.~%"
                                                                  `(|every| ,cexpr |has-definition| ,@slotsvals) cexpr))
                                                   ((are-slotsvals slotsvals)
                                                    (let* ((slotsvals00
                                                            (cond (*record-sources*
                                                                   (annotate-slotsvals slotsvals (make-source class)))
                                                                  (t slotsvals)))
                                                           (slotsvals0 (convert-comments-to-internal-form slotsvals00))
                                                           (parents-of-defined-concept
                                                            (desource+decomment (vals-in (assoc '|instance-of| slotsvals0))
                                                              :delistifyp nil)))
                                                      (cond ((not (every #'kb-objectp parents-of-defined-concept))
                                                             (report-error 'user-error
                                                                           "~a~%The `instance-of' slot-filler(s) in a has-definition must be atomic class name(s) only.~%"
                                                                           `(|every| ,cexpr |has-definition|
                                                                             ,@slotsvals0)))
                                                            ((null parents-of-defined-concept)
                                                             (report-error 'user-error
                                                                           "~a~%You must specify an `instance-of' slot value for a has-definition, pointing to the parent class(es)!~%"
                                                                           `(|every| ,cexpr |has-definition|
                                                                             ,@slotsvals0)))
                                                            (t
                                                             (add-slotsvals class slotsvals0
                                                               :facet 'member-definition
                                                               :install-inversesp nil)
                                                             (point-parents-to-defined-concept class
                                                                                               parents-of-defined-concept
                                                                                               'member-definition)
                                                             (km-setq '*are-some-definitions* t)
                                                             (mapc #'un-done (all-instances class))
                                                             (list class))))))))
                                       f-mode target xrl xrrr)
                              '(|every| ?cexpr |has-definition| &rest))))
                  (when (eql xrrl '|now-has-definition|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target cexpr slotsvals)
                                           (declare (ignore _fmode _target))
                                           (let ((class (km-unique-int cexpr :fail-mode 'error)))
                                             (cond ((not (kb-objectp class))
                                                    (report-error 'user-error
                                                                  "~a~%~a isn't/doesn't evaluate to a class name.~%"
                                                                  `(|every| ,cexpr |now-has-definition| ,@slotsvals)
                                                                  cexpr))
                                                   ((are-slotsvals slotsvals)
                                                    (let* ((slotsvals00
                                                            (cond (*record-sources*
                                                                   (annotate-slotsvals slotsvals (make-source class)))
                                                                  (t slotsvals)))
                                                           (slotsvals0 (convert-comments-to-internal-form slotsvals00))
                                                           (parents-of-defined-concept
                                                            (desource+decomment (vals-in (assoc '|instance-of| slotsvals0))
                                                              :delistifyp nil)))
                                                      (cond ((not (every #'kb-objectp parents-of-defined-concept))
                                                             (report-error 'user-error
                                                                           "~a~%The `instance-of' slot-filler(s) in a now-has-definition must be atomic class name(s) only.~%"
                                                                           `(|every| ,cexpr |now-has-definition|
                                                                             ,@slotsvals0)))
                                                            ((and (null parents-of-defined-concept) slotsvals0)
                                                             (report-error 'user-error
                                                                           "~a~%You must specify an `instance-of' slot value for a now-has-definition, pointing to the parent class(es)!~%"
                                                                           `(|every| ,cexpr |now-has-definition|
                                                                             ,@slotsvals0)))
                                                            (t
                                                             (let ((member-definition-parents
                                                                    (get-vals class '|instance-of|
                                                                      :facet 'member-definition)))
                                                               (cond (member-definition-parents
                                                                      (unpoint-parents-to-defined-concept class
                                                                        member-definition-parents 'member-definition))))
                                                             (mapc #'(lambda (situation)
                                                                       (mapc #'(lambda (slotvals)
                                                                                 (let ((slot (slot-in slotvals)))
                                                                                   (put-vals
                                                                                    class
                                                                                    slot
                                                                                    nil
                                                                                    :facet
                                                                                    'member-definition
                                                                                    :situation
                                                                                    situation)))
                                                                             (get-slotsvals class
                                                                               :situation situation
                                                                               :facet 'member-definition)))
                                                                   (all-situations-and-theories))
                                                             (cond (parents-of-defined-concept
                                                                    (add-slotsvals class slotsvals0
                                                                      :facet 'member-definition
                                                                      :install-inversesp nil)
                                                                    (point-parents-to-defined-concept class
                                                                                                      parents-of-defined-concept
                                                                                                      'member-definition)
                                                                    (km-setq '*are-some-definitions* t)
                                                                    (mapc #'un-done (all-instances class))))
                                                             (list class))))))))
                                       f-mode target xrl xrrr)
                              '(|every| ?cexpr |now-has-definition| &rest)))))))
          (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (fmode target frame)
                                   (km-int `(|every| ,frame |with|) :fail-mode fmode :target target :rewritep t))
                               f-mode target xrl)
                      '(|every| ?frame))))))
  ))
(defun h--xr (x xl xr f-mode target) (block km-handler
  (let ((xrl (first xr)) (xrr (rest xr)))
    (or (when (eql xrl '|has|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                 (declare (ignore _fmode _target))
                                 (let ((instance (km-unique-int instance-expr :fail-mode 'error)))
                                   (cond ((not (kb-objectp instance))
                                          (report-error 'user-error "~a~%~a isn't/doesn't evaluate to a KB object name.~%"
                                                        `(,instance-expr |has| ,@slotsvals) instance-expr))
                                         ((are-slotsvals slotsvals)
                                          (add-slotsvals instance (convert-comments-to-internal-form slotsvals))
                                          (make-assertions instance slotsvals)
                                          (un-done instance)
                                          (classify instance :slots-that-changed (mapcar #'slot-in slotsvals))
                                          (cond ((am-in-prototype-mode) (km-int '(|evaluate-paths|))))
                                          (list instance)))))
                             f-mode target xl xrr)
                    '(?instance-expr |has| &rest))))
        (when (eql xrl '|also-has|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                 (declare (ignore _fmode _target))
                                 (let ((instance (km-unique-int instance-expr :fail-mode 'error)))
                                   (cond ((not (kb-objectp instance))
                                          (report-error 'user-error "~a~%~a isn't/doesn't evaluate to a KB object name.~%"
                                                        `(,instance-expr |also-has| ,@slotsvals) instance-expr))
                                         ((are-slotsvals slotsvals)
                                          (add-slotsvals instance (convert-comments-to-internal-form slotsvals)
                                            :combine-values-by 'appending)
                                          (un-done instance)
                                          (classify instance :slots-that-changed (mapcar #'slot-in slotsvals))
                                          (cond ((am-in-prototype-mode) (km-int '(|evaluate-paths|))))
                                          (list instance)))))
                             f-mode target xl xrr)
                    '(?instance-expr |also-has| &rest))))
        (when (eql xrl '|also-hasnt|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                 (declare (ignore _fmode _target))
                                 (let ((instance (km-unique-int instance-expr :fail-mode 'error)))
                                   (cond ((not (kb-objectp instance))
                                          (report-error 'user-error "~a~%~a isn't/doesn't evaluate to a KB object name.~%"
                                                        `(,instance-expr |also-has| ,@slotsvals) instance-expr))
                                         ((are-slotsvals slotsvals)
                                          (mapc #'(lambda (slotvals)
                                                    (let ((slot (slot-in slotvals)) (vals (vals-in slotvals)))
                                                      (mapc #'(lambda (val) (delete-val instance slot val)) vals)))
                                                slotsvals)
                                          (un-done instance)
                                          (list instance)))))
                             f-mode target xl xrr)
                    '(?instance-expr |also-hasnt| &rest))))
        (when (eql xrl '|now-has|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                 (declare (ignore _fmode _target))
                                 (let ((instance (km-unique-int instance-expr :fail-mode 'error)))
                                   (cond ((not (kb-objectp instance))
                                          (report-error 'user-error "~a~%~a isn't/doesn't evaluate to a KB object name.~%"
                                                        `(,instance-expr |now-has| ,@slotsvals) instance-expr))
                                         ((are-slotsvals slotsvals)
                                          (add-slotsvals instance (convert-comments-to-internal-form slotsvals)
                                            :combine-values-by 'overwriting)
                                          (un-done instance)
                                          (classify instance)
                                          (list instance)))))
                             f-mode target xl xrr)
                    '(?instance-expr |now-has| &rest))))
        (when (eql xrl '&&)
          (return-from km-handler
            (values (funcall #'(lambda (fmode target xs rest)
                                 (declare (ignore fmode))
                                 (lazy-unify-&-expr `(,xs && ,@rest) :fail-mode 'error :joiner '&& :target target))
                             f-mode target xl xrr)
                    '(?xs && &rest))))
        (when (eql xrl '&)
          (return-from km-handler
            (values (funcall #'(lambda (fmode target x rest)
                                 (declare (ignore fmode))
                                 (lazy-unify-&-expr `(,x & ,@rest) :fail-mode 'error :joiner '& :target target))
                             f-mode target xl xrr)
                    '(?x & &rest))))
        (when (eql xrl '===)
          (return-from km-handler
            (values (funcall #'(lambda (fmode target xs rest)
                                 (declare (ignore fmode))
                                 (lazy-unify-&-expr `(,xs === ,@rest) :fail-mode 'error :joiner '=== :target target))
                             f-mode target xl xrr)
                    '(?xs === &rest))))
        (when (eql xrl '==)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (declare (ignore fmode))
                                       (lazy-unify-&-expr `(,x == ,y) :fail-mode 'error :joiner '== :target target))
                                   f-mode target xl xrrl)
                          '(?x == ?y)))))))
        (when (eql xrl '/==)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (declare (ignore fmode target))
                                       (let ((xv (km-unique-int x :fail-mode 'error))
                                             (yv (km-unique-int y :fail-mode 'error)))
                                         (cond ((equal xv yv)
                                                (report-error 'user-error "(~a /== ~a): ~a and ~a are the same object!~%" x
                                                              y x y))
                                               ((kb-objectp xv) (km-int `(,xv |has| (/== (,yv))) :fail-mode 'error))
                                               ((kb-objectp yv) (km-int `(,yv |has| (/== (,xv))) :fail-mode 'error))
                                               ('(|t|)))))
                                   f-mode target xl xrrl)
                          '(?x /== ?y)))))))
        (when (eql xrl '&&!)
          (return-from km-handler
            (values (funcall #'(lambda (fmode target xs rest)
                                 (declare (ignore fmode))
                                 (lazy-unify-&-expr `(,xs &&! ,@rest) :fail-mode 'error :joiner '&&! :target target))
                             f-mode target xl xrr)
                    '(?xs &&! &rest))))
        (when (eql xrl '&!)
          (return-from km-handler
            (values (funcall #'(lambda (fmode target x rest)
                                 (declare (ignore fmode))
                                 (lazy-unify-&-expr `(,x &! ,@rest) :fail-mode 'error :joiner '&! :target target))
                             f-mode target xl xrr)
                    '(?x &! &rest))))
        (when (eql xrl '&?)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode target x y)
                                       (declare (ignore _fmode target))
                                       (cond ((null x) '(|t|))
                                             ((null y) '(|t|))
                                             ((existential-exprp y)
                                              (let ((xf (km-unique-int x)))
                                                (cond ((null xf) '(|t|)) ((unifiable-with-existential-expr xf y) '(|t|)))))
                                             ((existential-exprp x)
                                              (let ((yf (km-unique-int y)))
                                                (cond ((null yf) '(|t|)) ((unifiable-with-existential-expr yf x) '(|t|)))))
                                             (t
                                              (let ((xv (km-unique-int x)))
                                                (cond ((null xv) '(|t|))
                                                      (t
                                                       (let ((yv (km-unique-int y)))
                                                         (cond ((null yv) '(|t|)) ((try-lazy-unify xv yv) '(|t|))))))))))
                                   f-mode target xl xrrl)
                          '(?x &? ?y)))))))
        (when (eql xrl '&+?)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode target x y)
                                       (declare (ignore _fmode target))
                                       (cond ((existential-exprp y)
                                              (let ((xf (km-unique-int x)))
                                                (cond ((null xf) '(|t|))
                                                      ((unifiable-with-existential-expr xf y :classes-subsumep t)
                                                       '(|t|)))))
                                             ((existential-exprp x)
                                              (let ((yf (km-unique-int y)))
                                                (cond ((null yf) '(|t|))
                                                      ((unifiable-with-existential-expr yf x :classes-subsumep t)
                                                       '(|t|)))))
                                             (t
                                              (let ((xv (km-unique-int x)))
                                                (cond ((null xv) '(|t|))
                                                      (t
                                                       (let ((yv (km-unique-int y)))
                                                         (cond ((null yv) '(|t|))
                                                               ((try-lazy-unify xv yv :classes-subsumep t) '(|t|))))))))))
                                   f-mode target xl xrrl)
                          '(?x &+? ?y)))))))
        (when (eql xrl '&+)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (let ((unification
                                              (lazy-unify-exprs x y :classes-subsumep t :fail-mode fmode :target target)))
                                         (cond (unification (list unification))
                                               ((eq fmode 'error)
                                                (report-error 'user-error "Unification (~a &+ ~a) failed!~%" x y)))))
                                   f-mode target xl xrrl)
                          '(?x &+ ?y)))))))
        (when (eql xrl '&+!)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (cond ((km-int `(,x &+? ,y) :target target :fail-mode fmode)
                                              (km-int `(,x &! ,y) :target target :fail-mode 'error))
                                             ((eq fmode 'error)
                                              (report-error 'user-error "Unification (~a &+! ~a) failed!~%" x y))))
                                   f-mode target xl xrrl)
                          '(?x &+! ?y)))))))
        (when (eql xrl '=)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (eql xrrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target x y)
                                           (declare (ignore target))
                                           (let ((xv (km-int x :fail-mode fmode)) (yv (km-int y :fail-mode fmode)))
                                             (cond ((km-set-equal (dereference xv) yv) '(|t|)))))
                                       f-mode target xl xrrl)
                              '(?x = ?y))))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (when (eql xrrrl '+/-)
                        (when (consp xrrrr)
                          (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                            (or (when (eql xrrrrr 'nil)
                                  (return-from km-handler
                                    (values (funcall #'(lambda (_fmode _target x y z)
                                                         (declare (ignore _fmode _target))
                                                         (let ((xval (km-unique-int x :fail-mode 'error))
                                                               (yval (km-unique-int y :fail-mode 'error))
                                                               (zval (km-unique-int z :fail-mode 'error)))
                                                           (cond ((and (numberp xval) (numberp yval) (numberp zval))
                                                                  (cond ((<= (abs (- xval yval)) (abs zval)) '(|t|)))))))
                                                     f-mode target xl xrrl xrrrrl)
                                            '(?x = ?y +/- ?z))))
                                (when (consp xrrrrr)
                                  (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                    (when (eql xrrrrrl '%)
                                      (when (eql xrrrrrr 'nil)
                                        (return-from km-handler
                                          (values (funcall #'(lambda (_fmode _target x y z)
                                                               (declare (ignore _fmode _target))
                                                               (let ((xval (km-unique-int x :fail-mode 'error))
                                                                     (yval (km-unique-int y :fail-mode 'error))
                                                                     (zval (km-unique-int z :fail-mode 'error)))
                                                                 (cond ((and (numberp xval) (numberp yval) (numberp zval))
                                                                        (cond ((<= (abs (- xval yval))
                                                                                   (*
                                                                                    (max (abs xval) (abs yval))
                                                                                    (abs zval)
                                                                                    0.01))
                                                                               '(|t|)))))))
                                                           f-mode target xl xrrl xrrrrl)
                                                  '(?x = ?y +/- ?z %)))))))))))))))))
        (when (eql xrl '/=)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (declare (ignore target))
                                       (let ((xv (km-int x :fail-mode fmode)) (yv (km-int y :fail-mode fmode)))
                                         (cond ((not (km-set-equal (dereference xv) yv)) '(|t|)))))
                                   f-mode target xl xrrl)
                          '(?x /= ?y)))))))
        (when (eql xrl '|has-definition|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                 (declare (ignore _fmode _target))
                                 (let ((instance (km-unique-int instance-expr :fail-mode 'error)))
                                   (cond ((not (kb-objectp instance))
                                          (report-error 'user-error "~a~%~a isn't/doesn't evaluate to a KB object name.~%"
                                                        `(|every| ,instance-expr |has-definition| ,@slotsvals)
                                                        instance-expr))
                                         ((are-slotsvals slotsvals)
                                          (let* ((slotsvals0 (desource+decomment slotsvals))
                                                 (parents-of-defined-concept (vals-in (assoc '|instance-of| slotsvals0))))
                                            (cond ((not (every #'kb-objectp parents-of-defined-concept))
                                                   (report-error 'user-error
                                                                 "~a~%The `instance-of' slot-filler(s) in a has-definition must be atomic class name(s) only.~%"
                                                                 `(,instance-expr |has-definition| ,@slotsvals0)))
                                                  ((null parents-of-defined-concept)
                                                   (report-error 'user-error
                                                                 "~a~%You must specify an `instance-of' slot value for a has-definition, pointing to the parent class(es)!~%"
                                                                 `(,instance-expr |has-definition| ,@slotsvals0)))
                                                  (t
                                                   (add-slotsvals instance slotsvals0 :facet 'own-definition)
                                                   (point-parents-to-defined-concept instance parents-of-defined-concept
                                                                                     'own-definition)
                                                   (km-setq '*are-some-definitions* t)
                                                   (un-done instance)
                                                   (classify instance :slots-that-changed (mapcar #'slot-in slotsvals))
                                                   (list instance))))))))
                             f-mode target xl xrr)
                    '(?instance-expr |has-definition| &rest))))
        (when (eql xrl '|now-has-definition|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target instance-expr slotsvals)
                                 (declare (ignore _fmode _target))
                                 (let ((instance (km-unique-int instance-expr :fail-mode 'error)))
                                   (cond ((not (kb-objectp instance))
                                          (report-error 'user-error "~a~%~a isn't/doesn't evaluate to a KB object name.~%"
                                                        `(|every| ,instance-expr |now-has-definition| ,@slotsvals)
                                                        instance-expr))
                                         ((are-slotsvals slotsvals)
                                          (let* ((slotsvals0 (desource+decomment slotsvals))
                                                 (parents-of-defined-concept (vals-in (assoc '|instance-of| slotsvals0))))
                                            (cond ((not (every #'kb-objectp parents-of-defined-concept))
                                                   (report-error 'user-error
                                                                 "~a~%The `instance-of' slot-filler(s) in a now-has-definition must be atomic class name(s) only.~%"
                                                                 `(,instance-expr |now-has-definition| ,@slotsvals0)))
                                                  ((and (null parents-of-defined-concept) slotsvals0)
                                                   (report-error 'user-error
                                                                 "~a~%You must specify an `instance-of' slot value for a now-has-definition, pointing to the parent class(es)!~%"
                                                                 `(,instance-expr |now-has-definition| ,@slotsvals0)))
                                                  (t
                                                   (let ((own-definition-parents
                                                          (get-vals instance '|instance-of| :facet 'own-definition)))
                                                     (cond (own-definition-parents
                                                            (unpoint-parents-to-defined-concept instance
                                                              own-definition-parents 'own-definition))))
                                                   (mapc #'(lambda (situation)
                                                             (mapc #'(lambda (slotvals)
                                                                       (let ((slot (slot-in slotvals))
                                                                             (vals (vals-in slotvals)))
                                                                         (uninstall-inverses instance slot vals situation)
                                                                         (put-vals instance slot nil
                                                                           :facet 'own-definition
                                                                           :situation situation)))
                                                                   (get-slotsvals instance
                                                                     :situation situation
                                                                     :facet 'own-definition)))
                                                         (all-situations-and-theories))
                                                   (cond (parents-of-defined-concept
                                                          (add-slotsvals instance slotsvals0 :facet 'own-definition)
                                                          (point-parents-to-defined-concept instance
                                                                                            parents-of-defined-concept
                                                                                            'own-definition)
                                                          (km-setq '*are-some-definitions* t)
                                                          (un-done instance)
                                                          (classify instance
                                                            :slots-that-changed (mapcar #'slot-in slotsvals))))
                                                   (list instance))))))))
                             f-mode target xl xrr)
                    '(?instance-expr |now-has-definition| &rest))))
        (when (eql xrl '>)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target x y)
                                       (declare (ignore _fmode _target))
                                       (let ((xval (km-unique-int x :fail-mode 'error))
                                             (yval (km-unique-int y :fail-mode 'error)))
                                         (cond ((and (numberp xval) (numberp yval)) (cond ((> xval yval) '(|t|)))))))
                                   f-mode target xl xrrl)
                          '(?x > ?y)))))))
        (when (eql xrl '<)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target x y)
                                       (declare (ignore _fmode _target))
                                       (let ((xval (km-unique-int x :fail-mode 'error))
                                             (yval (km-unique-int y :fail-mode 'error)))
                                         (cond ((and (numberp xval) (numberp yval)) (cond ((< xval yval) '(|t|)))))))
                                   f-mode target xl xrrl)
                          '(?x < ?y)))))))
        (when (eql xrl '>=)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target x y)
                                       (declare (ignore _fmode _target))
                                       (let ((xval (km-unique-int x :fail-mode 'error))
                                             (yval (km-unique-int y :fail-mode 'error)))
                                         (cond ((and (numberp xval) (numberp yval)) (cond ((>= xval yval) '(|t|)))))))
                                   f-mode target xl xrrl)
                          '(?x >= ?y)))))))
        (when (eql xrl '<=)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target x y)
                                       (declare (ignore _fmode _target))
                                       (let ((xval (km-unique-int x :fail-mode 'error))
                                             (yval (km-unique-int y :fail-mode 'error)))
                                         (cond ((and (numberp xval) (numberp yval)) (cond ((<= xval yval) '(|t|)))))))
                                   f-mode target xl xrrl)
                          '(?x <= ?y)))))))
        (when (eql xrl '|and|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target x rest)
                                 (declare (ignore _fmode _target))
                                 (cond ((and (listp x) (= (length x) 3) (eq (second x) '==))
                                        (let* ((xx (first x)) (yy (third x)))
                                          (cond ((and (km-varp xx) (km-varp yy)) (km-int (subst xx yy rest)))
                                                ((km-varp xx) (km-int (subst (vals-to-val (km-int yy)) xx rest)))
                                                ((km-varp yy) (km-int (subst (vals-to-val (km-int xx)) yy rest)))
                                                ((and (lazy-unify-&-expr `(,xx == yy) :fail-mode 'error :joiner '==)
                                                      (km-int rest))))))
                                       (t (and (km-int x) (km-int rest)))))
                             f-mode target xl xrr)
                    '(?x |and| &rest))))
        (when (eql xrl '|or|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target x y)
                                 (declare (ignore _fmode _target))
                                 (or (and (not (on-goal-stackp x)) (km-int x)) (km-int y)))
                             f-mode target xl xrr)
                    '(?x |or| &rest))))
        (when (eql xrl '|is-subsumed-by|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (km-int `(,y |subsumes| ,x) :fail-mode fmode :target target :rewritep t))
                                   f-mode target xl xrrl)
                          '(?x |is-subsumed-by| ?y)))))))
        (when (eql xrl '|subsumes|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target x y)
                                       (declare (ignore _fmode _target))
                                       (let ((yv (km-int y)))
                                         (cond ((null yv) '(|t|))
                                               (t
                                                (let ((xv (km-int x)))
                                                  (cond ((and (not (null xv)) (subsumes xv yv)) '(|t|))))))))
                                   f-mode target xl xrrl)
                          '(?x |subsumes| ?y)))))))
        (when (eql xrl '|is-covered-by|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (km-int `(,y |covers| ,x) :fail-mode fmode :target target :rewritep t))
                                   f-mode target xl xrrl)
                          '(?x |is-covered-by| ?y)))))))
        (when (eql xrl '|covers|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target x y)
                                       (km-int `(,y |isa| ,x) :fail-mode fmode :target target :rewritep t))
                                   f-mode target xl xrrl)
                          '(?x |covers| ?y)))))))
        (when (eql xrl '|isa|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target y x)
                                       (declare (ignore _fmode _target))
                                       (let* ((yvals (km-int y)) (yv (first yvals)))
                                         (cond ((null yvals)
                                                (report-error 'user-error
                                                              "Doing ~a:~% ~a evaluates to nil (should evaluate to an instance!)~%"
                                                              `(,y |isa| ,x) y))
                                               ((not (singletonp yvals))
                                                (report-error 'user-error
                                                              "Doing ~a:~% ~a evaluates to multiple values ~a (should evaluate to a single instance!)~%"
                                                              `(,y |isa| ,x) y yvals))
                                               (t
                                                (let* ((xvals (km-int x)) (xv (first xvals)))
                                                  (cond ((null xvals)
                                                         (report-error 'user-error
                                                                       "Doing ~a:~% ~a evaluates to nil (should evaluate to something!)~%"
                                                                       `(,y |isa| ,x) x))
                                                        ((not (singletonp xvals))
                                                         (report-error 'user-error
                                                                       "Doing ~a:~% ~a evaluates to multiple values ~a (should evaluate to a single object!)~%"
                                                                       `(,y |isa| ,x) x xvals))
                                                        ((kb-objectp xv) (cond ((isa yv xv) '(|t|))))
                                                        ((covers (list xv) yv) '(|t|))))))))
                                   f-mode target xl xrrl)
                          '(?y |isa| ?x)))))))
        (when (eql xrl '|is|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target x y)
                                       (declare (ignore _fmode _target))
                                       (let ((xv (km-unique-int x)))
                                         (cond ((null xv) nil)
                                               (t
                                                (let ((yv (km-unique-int y)))
                                                  (cond ((and (not (null yv)) (is xv yv)) '(|t|))))))))
                                   f-mode target xl xrrl)
                          '(?x |is| ?y)))))))
        (when (eql xrl '|includes|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target xs y)
                                       (declare (ignore _fmode _target))
                                       (let ((xs-vals (km-int xs)) (y-val (km-unique-int y)))
                                         (cond ((member y-val (dereference xs-vals) :test #'equal) '(|t|)))))
                                   f-mode target xl xrrl)
                          '(?xs |includes| ?y)))))))
        (when (eql xrl '|is-superset-of|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target xs ys)
                                       (declare (ignore _fmode _target))
                                       (let ((xs-vals (km-int xs)) (ys-vals (km-int ys)))
                                         (cond ((subsetp ys-vals (dereference xs-vals) :test #'equal) '(|t|)))))
                                   f-mode target xl xrrl)
                          '(?xs |is-superset-of| ?ys)))))))
        (when (eql xrl '|append|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target seq-expr1 seq-expr2)
                                       (declare (ignore _fmode _target))
                                       (let* ((seq1 (km-unique-int seq-expr1))
                                              (seq2 (km-unique-int seq-expr2))
                                              (elts1
                                               (cond ((or (km-seqp seq1) (km-bagp seq1)) (seq-to-list seq1))
                                                     ((null seq1) nil)
                                                     ((is-km-term seq1) (list seq1))
                                                     (t
                                                      (report-error 'user-error
                                                                    "(~a append ~a): ~a doesn't evaluate to an instance, sequence, or bag!"
                                                                    seq-expr1 seq-expr2 seq-expr1))))
                                              (elts2
                                               (cond ((or (km-seqp seq2) (km-bagp seq2)) (seq-to-list seq2))
                                                     ((null seq2) nil)
                                                     ((is-km-term seq2) (list seq2))
                                                     (t
                                                      (report-error 'user-error
                                                                    "(~a append ~a): ~a doesn't evaluate to an instance, sequence, or bag!"
                                                                    seq-expr1 seq-expr2 seq-expr2))))
                                              (result-type
                                               (cond ((or (and (km-seqp seq1) (km-bagp seq2))
                                                          (and (km-seqp seq2) (km-bagp seq1)))
                                                      (report-error 'user-error
                                                                    "(~a append ~a): Elements should be both sequences or both bags!"
                                                                    seq-expr1 seq-expr2)
                                                      ':|seq|)
                                                     ((or (km-bagp seq1) (km-bagp seq2)) ':|bag|)
                                                     (t ':|seq|))))
                                         `((,result-type ,@(append elts1 elts2)))))
                                   f-mode target xl xrrl)
                          '(?seq-expr1 |append| ?seq-expr2)))))))
        (when (eql xrl '|called|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode _target expr tag)
                                       (declare (ignore _target))
                                       (let* ((vals (km-int expr)))
                                         (cond (vals
                                                (km-trace 'comment "Now find just those value(s) whose tag = ~a..." tag)))
                                         (let* ((tags (val-to-vals tag))
                                                (target-vals
                                                 (remove-if
                                                    #'(lambda (val)
                                                        (set-difference tags
                                                                        (append (km-int `(|the| |called| |of| ,val))
                                                                                (km-int
                                                                                   `(|the| |uniquely-called| |of| ,val)))
                                                          :test #'equal))
                                                    vals)))
                                           (cond ((null target-vals)
                                                  (cond ((eq fmode 'error)
                                                         (report-error 'user-error
                                                                       "(~a called/uniquely-called ~a): No values of ~a (evaluates to ~a) is called/uniquely-called ~a!"
                                                                       expr tag expr vals (val-to-vals tag)))))
                                                 (t target-vals)))))
                                   f-mode target xl xrrl)
                          '(?expr |called| ?tag)))))))
        (when (eql xrl '|uniquely-called|)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target expr tag)
                                       (km-int `(,expr |called| ,tag) :fail-mode fmode :target target :rewritep t))
                                   f-mode target xl xrrl)
                          '(?expr |uniquely-called| ?tag)))))))
        (when (eql xrl '^)
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (or (when (eql xrrrl '^)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x ^ ,y) ^ ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x ^ ?y ^ &rest))))
                          (when (eql xrrrl '+)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x ^ ,y) + ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x ^ ?y + &rest))))
                          (when (eql xrrrl '-)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x ^ ,y) - ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x ^ ?y - &rest))))
                          (when (eql xrrrl '/)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x ^ ,y) / ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x ^ ?y / &rest))))
                          (when (eql xrrrl '*)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x ^ ,y) * ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x ^ ?y * &rest)))))))
                  (when (eql xrrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr1 expr2)
                                           (let ((x (km-unique-int expr1 :fail-mode fmode :target target :rewritep t))
                                                 (y (km-unique-int expr2 :fail-mode fmode :target target :rewritep t)))
                                             (cond ((and (numberp x) (numberp y)) (list (expt x y))))))
                                       f-mode target xl xrrl)
                              '(?expr1 ^ ?expr2))))))))
        (when (eql xrl '/)
          (or (when (consp xrr)
                (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (or (when (eql xrrrl '+)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x / ,y) + ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x / ?y + &rest))))
                          (when (eql xrrrl '-)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x / ,y) - ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x / ?y - &rest))))
                          (when (eql xrrrl '/)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x / ,y) / ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x / ?y / &rest))))
                          (when (eql xrrrl '*)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x / ,y) * ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x / ?y * &rest)))))))))
              (return-from km-handler
                (values (funcall #'(lambda (fmode target expr rest)
                                     (let ((x (km-unique-int expr :fail-mode fmode :target target :rewritep t))
                                           (y (km-unique-int rest :fail-mode fmode :target target :rewritep t)))
                                       (cond ((and (numberp x) (numberp y))
                                              (cond ((and (zerop x) (zerop y) (list 1)))
                                                    ((zerop x) (list 0))
                                                    ((zerop y) (list *infinity*))
                                                    ((and (numberp x) (numberp y)) (list (/ x y))))))))
                                 f-mode target xl xrr)
                        '(?expr / &rest)))))
        (when (eql xrl '*)
          (or (when (consp xrr)
                (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (or (when (eql xrrrl '+)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x * ,y) + ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x * ?y + &rest))))
                          (when (eql xrrrl '-)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x * ,y) - ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x * ?y - &rest))))
                          (when (eql xrrrl '/)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x * ,y) / ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x * ?y / &rest)))))))))
              (return-from km-handler
                (values (funcall #'(lambda (fmode target expr rest)
                                     (let ((x (km-unique-int expr :fail-mode fmode :target target :rewritep t))
                                           (y (km-unique-int rest :fail-mode fmode :target target :rewritep t)))
                                       (cond ((and (numberp x) (numberp y)) (list (* x y))))))
                                 f-mode target xl xrr)
                        '(?expr * &rest)))))
        (when (eql xrl '-)
          (or (when (consp xrr)
                (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (or (when (eql xrrrl '-)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x - ,y) - ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x - ?y - &rest))))
                          (when (eql xrrrl '+)
                            (return-from km-handler
                              (values (funcall #'(lambda (fm tg x y rest)
                                                   (declare (ignore tg))
                                                   (km-int `((,x - ,y) + ,@rest) :fail-mode fm))
                                               f-mode target xl xrrl xrrrr)
                                      '(?x - ?y + &rest)))))))))
              (return-from km-handler
                (values (funcall #'(lambda (fmode target expr rest)
                                     (let ((x (km-unique-int expr :fail-mode fmode :target target :rewritep t))
                                           (y (km-unique-int rest :fail-mode fmode :target target :rewritep t)))
                                       (cond ((and (numberp x) (numberp y)) (list (- x y))))))
                                 f-mode target xl xrr)
                        '(?expr - &rest)))))
        (when (eql xrl '+)
          (or (when (consp xrr)
                (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (when (eql xrrrl '-)
                        (return-from km-handler
                          (values (funcall #'(lambda (fm tg x y rest)
                                               (declare (ignore tg))
                                               (km-int `((,x + ,y) - ,@rest) :fail-mode fm))
                                           f-mode target xl xrrl xrrrr)
                                  '(?x + ?y - &rest))))))))
              (return-from km-handler
                (values (funcall #'(lambda (fmode target expr rest)
                                     (let ((x (km-unique-int expr :fail-mode fmode :target target :rewritep t))
                                           (y (km-unique-int rest :fail-mode fmode :target target :rewritep t)))
                                       (cond ((and (numberp x) (numberp y)) (list (+ x y))))))
                                 f-mode target xl xrr)
                        '(?expr + &rest)))))))
  ))
    ;--edge
(defun h--the+ (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (eql xrrl '|of|)
                    (when (consp xrrr)
                      (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                        (when (eql xrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode target slot frameadd)
                                                 (declare (ignore _fmode))
                                                 (km-int `(|the+| |Thing| |with| (,(invert-slot slot) (,frameadd)))
                                                   :fail-mode 'error
                                                   :target target
                                                   :rewritep t))
                                             f-mode target xrl xrrrl)
                                    '(|the+| ?slot |of| ?frameadd)))))))
                  (when (consp xrrr)
                    (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                      (when (eql xrrrl '|of|)
                        (when (consp xrrrr)
                          (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                            (when (eql xrrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (_fmode target class slot frameadd)
                                                     (declare (ignore _fmode))
                                                     (km-int `(|the+| ,class |with| (,(invert-slot slot) (,frameadd)))
                                                       :fail-mode 'error
                                                       :target target
                                                       :rewritep t))
                                                 f-mode target xrl xrrl xrrrrl)
                                        '(|the+| ?class ?slot |of| ?frameadd)))))))))
                  (when (eql xrrl '|with|)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target frame slotsvals)
                                           (declare (ignore _fmode _target))
                                           (let ((val (km-unique-int `(|every| ,frame |with| ,@slotsvals))))
                                             (cond (val (list val))
                                                   ((are-slotsvals slotsvals)
                                                    (let ((existential-expr
                                                           (cond ((and (null slotsvals) (pathp frame))
                                                                  (path-to-existential-expr frame))
                                                                 (t `(|a| ,frame |with| ,@slotsvals)))))
                                                      (mapcar #'eval-instance
                                                              (km-int existential-expr :fail-mode 'error)))))))
                                       f-mode target xrl xrrr)
                              '(|the+| ?frame |with| &rest)))))))
          (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (fmode target frame)
                                   (km-int `(|the+| ,frame |with|) :fail-mode fmode :target target :rewritep t))
                               f-mode target xrl)
                      '(|the+| ?frame))))))
  ))
(defun h--allof (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (or (when (eql xrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (fmode target set test)
                                                 (km-int `(|forall| ,set |where| ,test |It|)
                                                   :fail-mode fmode
                                                   :target target
                                                   :rewritep t))
                                             f-mode target xrl xrrrl)
                                    '(|allof| ?set |where| ?test))))
                        (when (consp xrrrr)
                          (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                            (when (eql xrrrrl '|must|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (when (eql xrrrrrr 'nil)
                                    (return-from km-handler
                                      (values (funcall #'(lambda (fmode target set test2 test)
                                                           (declare (ignore fmode target))
                                                           (cond ((every #'(lambda (instance)
                                                                             (km-int (subst instance '|It| test)))
                                                                         (km-int `(|allof| ,set |where| ,test2)))
                                                                  '(|t|))))
                                                       f-mode target xrl xrrrl xrrrrrl)
                                              '(|allof| ?set |where| ?test2 |must| ?test)))))))))))))
              (when (eql xrrl '|must|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target set test)
                                             (declare (ignore fmode target))
                                             (cond ((every #'(lambda (instance) (km-int (subst instance '|It| test)))
                                                           (km-int set))
                                                    '(|t|))))
                                         f-mode target xrl xrrrl)
                                '(|allof| ?set |must| ?test)))))))
              (when (eql xrrl '|in|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (or (when (eql xrrrrl '|where|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (or (when (eql xrrrrrr 'nil)
                                        (return-from km-handler
                                          (values (funcall #'(lambda (fmode target var set test)
                                                               (cond ((not (km-varp var))
                                                                      (report-error 'user-error
                                                                                    "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                                    `(|allof|
                                                                                      ,var
                                                                                      |in|
                                                                                      ,set
                                                                                      |where|
                                                                                      ,test)))
                                                                     (t
                                                                      (km-int `(|forall| ,var |in| ,set |where| ,test ,var)
                                                                        :fail-mode fmode
                                                                        :target target
                                                                        :rewritep t))))
                                                           f-mode target xrl xrrrl xrrrrrl)
                                                  '(|allof| ?var |in| ?set |where| ?test))))
                                      (when (consp xrrrrrr)
                                        (let ((xrrrrrrl (first xrrrrrr)) (xrrrrrrr (rest xrrrrrr)))
                                          (when (eql xrrrrrrl '|must|)
                                            (when (consp xrrrrrrr)
                                              (let ((xrrrrrrrl (first xrrrrrrr)) (xrrrrrrrr (rest xrrrrrrr)))
                                                (when (eql xrrrrrrrr 'nil)
                                                  (return-from km-handler
                                                    (values (funcall #'(lambda (fmode target var set test2 test)
                                                                         (declare (ignore fmode target))
                                                                         (allof-where-must var set test2 test))
                                                                     f-mode target xrl xrrrl xrrrrrl xrrrrrrrl)
                                                            '(|allof| ?var |in| ?set |where| ?test2 |must|
                                                              ?test)))))))))))))
                            (when (eql xrrrrl '|must|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (when (eql xrrrrrr 'nil)
                                    (return-from km-handler
                                      (values (funcall #'(lambda (fmode target var set test)
                                                           (declare (ignore fmode target))
                                                           (allof-must var set test))
                                                       f-mode target xrl xrrrl xrrrrrl)
                                              '(|allof| ?var |in| ?set |must| ?test)))))))))))))))))
  ))
(defun h--forall (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target set value)
                                       (km-int `(|forall| ,set |where| t ,value)
                                         :fail-mode fmode
                                         :target target
                                         :rewritep t))
                                   f-mode target xrl xrrl)
                          '(|forall| ?set ?value))))
              (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode _target set constraint value)
                                                 (declare (ignore _fmode _target))
                                                 (remove nil
                                                         (my-mapcan #'(lambda (member)
                                                                        (cond ((km-int (subst member '|It| constraint))
                                                                               (km-int (subst member '|It| value)))))
                                                                    (km-int set))))
                                             f-mode target xrl xrrrl xrrrrl)
                                    '(|forall| ?set |where| ?constraint ?value)))))))))
              (when (eql xrrl '|in|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (or (when (eql xrrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (fmode target var set value)
                                                     (cond ((not (km-varp var))
                                                            (report-error 'user-error
                                                                          "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                          `(|forall| ,var |in| ,set ,value)))
                                                           (t
                                                            (km-int `(|forall| ,var |in| ,set |where| t ,value)
                                                              :fail-mode fmode
                                                              :target target
                                                              :rewritep t))))
                                                 f-mode target xrl xrrrl xrrrrl)
                                        '(|forall| ?var |in| ?set ?value))))
                            (when (eql xrrrrl '|where|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (when (consp xrrrrrr)
                                    (let ((xrrrrrrl (first xrrrrrr)) (xrrrrrrr (rest xrrrrrr)))
                                      (when (eql xrrrrrrr 'nil)
                                        (return-from km-handler
                                          (values (funcall #'(lambda (_fmode _target var set constraint value)
                                                               (declare (ignore _fmode _target))
                                                               (cond ((not (km-varp var))
                                                                      (report-error 'user-error
                                                                                    "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                                    `(|forall|
                                                                                      ,var
                                                                                      |in|
                                                                                      ,set
                                                                                      |where|
                                                                                      ,constraint
                                                                                      ,value)))
                                                                     (t
                                                                      (remove nil
                                                                              (my-mapcan #'(lambda
                                                                                            (member)
                                                                                            (cond
                                                                                             ((km-int
                                                                                               (subst
                                                                                                member
                                                                                                var
                                                                                                constraint))
                                                                                              (km-int
                                                                                               (subst member var value)))))
                                                                                         (km-int set))))))
                                                           f-mode target xrl xrrrl xrrrrrl xrrrrrrl)
                                                  '(|forall| ?var |in| ?set |where| ?constraint ?value)))))))))))))))))))
  ))
(defun h--forall-seq (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target seq value)
                                       (km-int `(|forall-seq| ,seq |where| t ,value)
                                         :fail-mode fmode
                                         :target target
                                         :rewritep t))
                                   f-mode target xrl xrrl)
                          '(|forall-seq| ?seq ?value))))
              (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode _target seq constraint value)
                                                 (declare (ignore _fmode _target))
                                                 (let ((sequences (km-int seq)))
                                                   (cond ((null sequences) nil)
                                                         ((or (not (singletonp sequences))
                                                              (not (km-seqp (first sequences))))
                                                          (report-error 'user-error
                                                                        "~a: ~a should evaluate to a single sequence (:seq ... ...)!~%"
                                                                        `(|forall-seq| ,seq |where| ,constraint ,value)
                                                                        seq))
                                                         (t
                                                          (list (cons ':|seq|
                                                                      (remove 'to-remove
                                                                              (mapcar #'(lambda
                                                                                         (member)
                                                                                         (cond
                                                                                          ((km-int
                                                                                            (subst
                                                                                             member
                                                                                             '|It|
                                                                                             constraint))
                                                                                           (vals-to-val
                                                                                            (km-int
                                                                                             (subst member '|It| value))))
                                                                                          (t 'to-remove)))
                                                                                      (rest (first sequences))))))))))
                                             f-mode target xrl xrrrl xrrrrl)
                                    '(|forall-seq| ?seq |where| ?constraint ?value)))))))))
              (when (eql xrrl '|in|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (or (when (eql xrrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (fmode target var seq value)
                                                     (cond ((not (km-varp var))
                                                            (report-error 'user-error
                                                                          "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                          `(|forall-seq| ,var |in| ,seq ,value)))
                                                           (t
                                                            (km-int `(|forall-seq| ,var |in| ,seq |where| t ,value)
                                                              :fail-mode fmode
                                                              :target target
                                                              :rewritep t))))
                                                 f-mode target xrl xrrrl xrrrrl)
                                        '(|forall-seq| ?var |in| ?seq ?value))))
                            (when (eql xrrrrl '|where|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (when (consp xrrrrrr)
                                    (let ((xrrrrrrl (first xrrrrrr)) (xrrrrrrr (rest xrrrrrr)))
                                      (when (eql xrrrrrrr 'nil)
                                        (return-from km-handler
                                          (values (funcall #'(lambda (_fmode _target var seq constraint value)
                                                               (declare (ignore _fmode _target))
                                                               (cond ((not (km-varp var))
                                                                      (report-error 'user-error
                                                                                    "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                                    `(|forall-seq|
                                                                                      ,var
                                                                                      |in|
                                                                                      ,seq
                                                                                      |where|
                                                                                      ,constraint
                                                                                      ,value)))
                                                                     (t
                                                                      (let ((sequences (km-int seq)))
                                                                        (cond ((or (not (singletonp sequences))
                                                                                   (not (km-seqp (first sequences))))
                                                                               (report-error 'user-error
                                                                                             "~a: ~a should evaluate to a single sequence (:seq ... ...)!~%"
                                                                                             `(|forall-seq|
                                                                                               ,var
                                                                                               |in|
                                                                                               ,seq
                                                                                               |where|
                                                                                               ,constraint
                                                                                               ,value)
                                                                                             seq))
                                                                              (t
                                                                               (list (cons
                                                                                      ':|seq|
                                                                                      (remove
                                                                                       'to-remove
                                                                                       (mapcar
                                                                                        #'(lambda
                                                                                           (member)
                                                                                           (cond
                                                                                            ((km-int
                                                                                              (subst
                                                                                               member
                                                                                               var
                                                                                               constraint))
                                                                                             (vals-to-val
                                                                                              (km-int
                                                                                               (subst member var value))))
                                                                                            (t 'to-remove)))
                                                                                        (rest (first sequences))))))))))))
                                                           f-mode target xrl xrrrl xrrrrrl xrrrrrrl)
                                                  '(|forall-seq| ?var |in| ?seq |where| ?constraint
                                                    ?value)))))))))))))))))))
  ))
(defun h--forall-bag (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target bag value)
                                       (km-int `(|forall-bag| ,bag |where| t ,value)
                                         :fail-mode fmode
                                         :target target
                                         :rewritep t))
                                   f-mode target xrl xrrl)
                          '(|forall-bag| ?bag ?value))))
              (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode _target bag constraint value)
                                                 (declare (ignore _fmode _target))
                                                 (let ((bags (km-int bag)))
                                                   (cond ((null bags) nil)
                                                         ((or (not (singletonp bags)) (not (km-bagp (first bags))))
                                                          (report-error 'user-error
                                                                        "~a: ~a should evaluate to a single bag (:bag ... ...)!~%"
                                                                        `(|forall-bag| ,bag |where| ,constraint ,value)
                                                                        bag))
                                                         (t
                                                          (list (cons ':|bag|
                                                                      (remove nil
                                                                              (mapcar #'(lambda
                                                                                         (member)
                                                                                         (cond
                                                                                          ((km-int
                                                                                            (subst
                                                                                             member
                                                                                             '|It|
                                                                                             constraint))
                                                                                           (vals-to-val
                                                                                            (km-int
                                                                                             (subst
                                                                                              member
                                                                                              '|It|
                                                                                              value))))))
                                                                                      (rest (first bags))))))))))
                                             f-mode target xrl xrrrl xrrrrl)
                                    '(|forall-bag| ?bag |where| ?constraint ?value)))))))))
              (when (eql xrrl '|in|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (or (when (eql xrrrrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (fmode target var bag value)
                                                     (cond ((not (km-varp var))
                                                            (report-error 'user-error
                                                                          "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                          `(|forall-bag| ,var |in| ,bag ,value)))
                                                           (t
                                                            (km-int `(|forall-bag| ,var |in| ,bag |where| t ,value)
                                                              :fail-mode fmode
                                                              :target target
                                                              :rewritep t))))
                                                 f-mode target xrl xrrrl xrrrrl)
                                        '(|forall-bag| ?var |in| ?bag ?value))))
                            (when (eql xrrrrl '|where|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (when (consp xrrrrrr)
                                    (let ((xrrrrrrl (first xrrrrrr)) (xrrrrrrr (rest xrrrrrr)))
                                      (when (eql xrrrrrrr 'nil)
                                        (return-from km-handler
                                          (values (funcall #'(lambda (_fmode _target var bag constraint value)
                                                               (declare (ignore _fmode _target))
                                                               (cond ((not (km-varp var))
                                                                      (report-error 'user-error
                                                                                    "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                                    `(|forall-bag|
                                                                                      ,var
                                                                                      |in|
                                                                                      ,bag
                                                                                      |where|
                                                                                      ,constraint
                                                                                      ,value)))
                                                                     (t
                                                                      (let ((bags (km-int bag)))
                                                                        (cond ((or (not (singletonp bags))
                                                                                   (not (km-bagp (first bags))))
                                                                               (report-error 'user-error
                                                                                             "~a: ~a should evaluate to a single bag (:bag ... ...)!~%"
                                                                                             `(|forall-bag|
                                                                                               ,var
                                                                                               |in|
                                                                                               ,bag
                                                                                               |where|
                                                                                               ,constraint
                                                                                               ,value)
                                                                                             bag))
                                                                              (t
                                                                               (list (cons
                                                                                      ':|bag|
                                                                                      (remove
                                                                                       nil
                                                                                       (mapcar
                                                                                        #'(lambda
                                                                                           (member)
                                                                                           (cond
                                                                                            ((km-int
                                                                                              (subst
                                                                                               member
                                                                                               var
                                                                                               constraint))
                                                                                             (vals-to-val
                                                                                              (km-int
                                                                                               (subst
                                                                                                member
                                                                                                var
                                                                                                value))))))
                                                                                        (rest (first bags))))))))))))
                                                           f-mode target xrl xrrrl xrrrrrl xrrrrrrl)
                                                  '(|forall-bag| ?var |in| ?bag |where| ?constraint
                                                    ?value)))))))))))))))))))
  ))
(defun h--forall-seq2 (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode _target seq constraint value)
                                                 (declare (ignore _fmode _target))
                                                 (let ((sequences (km-int seq)))
                                                   (cond ((null sequences) nil)
                                                         ((or (not (singletonp sequences))
                                                              (not (km-seqp (first sequences))))
                                                          (report-error 'user-error
                                                                        "~a: ~a should evaluate to a single sequence (:seq ... ...)!~%"
                                                                        `(|forall-seq2| ,seq |where| ,constraint ,value)
                                                                        seq))
                                                         (t
                                                          (list (cons ':|seq|
                                                                      (remove 'to-remove
                                                                              (mapcar #'(lambda
                                                                                         (member)
                                                                                         (cond
                                                                                          ((km-int
                                                                                            (subst
                                                                                             member
                                                                                             '|It2|
                                                                                             constraint))
                                                                                           (vals-to-val
                                                                                            (km-int
                                                                                             (subst member '|It2| value))))
                                                                                          (t 'to-remove)))
                                                                                      (rest (first sequences))))))))))
                                             f-mode target xrl xrrrl xrrrrl)
                                    '(|forall-seq2| ?seq |where| ?constraint ?value)))))))))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target seq value)
                                       (km-int `(|forall-seq2| ,seq |where| t ,value)
                                         :fail-mode fmode
                                         :target target
                                         :rewritep t))
                                   f-mode target xrl xrrl)
                          '(|forall-seq2| ?seq ?value))))))))
  ))
(defun h--forall-bag2 (x xl xr f-mode target) (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode _target bag constraint value)
                                                 (declare (ignore _fmode _target))
                                                 (let ((bags (km-int bag)))
                                                   (cond ((null bags) nil)
                                                         ((or (not (singletonp bags)) (not (km-bagp (first bags))))
                                                          (report-error 'user-error
                                                                        "~a: ~a should evaluate to a single bag (:bag ... ...)!~%"
                                                                        `(|forall-bag2| ,bag |where| ,constraint ,value)
                                                                        bag))
                                                         (t
                                                          (list (cons ':|bag|
                                                                      (remove nil
                                                                              (mapcar #'(lambda
                                                                                         (member)
                                                                                         (cond
                                                                                          ((km-int
                                                                                            (subst
                                                                                             member
                                                                                             '|It2|
                                                                                             constraint))
                                                                                           (vals-to-val
                                                                                            (km-int
                                                                                             (subst
                                                                                              member
                                                                                              '|It2|
                                                                                              value))))))
                                                                                      (rest (first bags))))))))))
                                             f-mode target xrl xrrrl xrrrrl)
                                    '(|forall-bag2| ?bag |where| ?constraint ?value)))))))))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target bag value)
                                       (km-int `(|forall-bag2| ,bag |where| t ,value)
                                         :fail-mode fmode
                                         :target target
                                         :rewritep t))
                                   f-mode target xrl xrrl)
                          '(|forall-bag2| ?bag ?value))))))))
  ))
(defun h--allof2 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (or (when (eql xrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (fmode target set test)
                                                 (km-int `(|forall2| ,set |where| ,test |It2|)
                                                   :fail-mode fmode
                                                   :target target
                                                   :rewritep t))
                                             f-mode target xrl xrrrl)
                                    '(|allof2| ?set |where| ?test))))
                        (when (consp xrrrr)
                          (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                            (when (eql xrrrrl '|must|)
                              (when (consp xrrrrr)
                                (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                                  (when (eql xrrrrrr 'nil)
                                    (return-from km-handler
                                      (values (funcall #'(lambda (fmode target set test2 test)
                                                           (declare (ignore fmode target))
                                                           (cond ((every #'(lambda (instance)
                                                                             (km-int (subst instance '|It2| test)))
                                                                         (km-int `(|allof2| ,set |where| ,test2)))
                                                                  '(|t|))))
                                                       f-mode target xrl xrrrl xrrrrrl)
                                              '(|allof2| ?set |where| ?test2 |must| ?test)))))))))))))
              (when (eql xrrl '|must|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target set test)
                                             (declare (ignore fmode target))
                                             (cond ((every #'(lambda (instance) (km-int (subst instance '|It2| test)))
                                                           (km-int set))
                                                    '(|t|))))
                                         f-mode target xrl xrrrl)
                                '(|allof2| ?set |must| ?test)))))))))))
  ))
(defun h--forall2 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target set value)
                                       (km-int `(|forall2| ,set |where| t ,value)
                                         :fail-mode fmode
                                         :target target
                                         :rewritep t))
                                   f-mode target xrl xrrl)
                          '(|forall2| ?set ?value))))
              (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrr 'nil)
                          (return-from km-handler
                            (values (funcall #'(lambda (_fmode _target set constraint value)
                                                 (declare (ignore _fmode _target))
                                                 (remove 'nil
                                                         (my-mapcan #'(lambda (member)
                                                                        (cond ((km-int (subst member '|It2| constraint))
                                                                               (km-int (subst member '|It2| value)))))
                                                                    (km-int set))))
                                             f-mode target xrl xrrrl xrrrrl)
                                    '(|forall2| ?set |where| ?constraint ?value)))))))))))))
  ))
(defun h--theoneof2 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (when (eql xrrl '|where|)
            (when (consp xrrr)
              (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                (when (eql xrrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target set test)
                                         (let ((val
                                                (km-unique-int `(|forall2| ,set |where| ,test |It2|)
                                                  :fail-mode fmode
                                                  :target target
                                                  :rewritep t)))
                                           (cond (val (list val)))))
                                     f-mode target xrl xrrrl)
                            '(|theoneof2| ?set |where| ?test))))))))))
  ))
(defun h--the1 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrl '|of|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target slot frameadd)
                                             (km-int `(|the1| |of| (|the| ,slot |of| ,frameadd))
                                               :fail-mode fmode
                                               :target target
                                               :rewritep t))
                                         f-mode target xrl xrrrl)
                                '(|the1| ?slot |of| ?frameadd)))))))))
          (when (eql xrl '|of|)
            (when (consp xrr)
              (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                (when (eql xrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target frameadd)
                                         (let ((multiargs (km-int frameadd :fail-mode fmode :target target :rewritep t)))
                                           (km-int
                                              (vals-to-val (mapcar #'(lambda (multiarg)
                                                                       (cond ((km-structured-list-valp multiarg)
                                                                              (arg1of multiarg))
                                                                             (t multiarg)))
                                                                   multiargs)))))
                                     f-mode target xrrl)
                            '(|the1| |of| ?frameadd)))))))))
  ))
(defun h--the2 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrl '|of|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target slot frameadd)
                                             (km-int `(|the2| |of| (|the| ,slot |of| ,frameadd))
                                               :fail-mode fmode
                                               :target target
                                               :rewritep t))
                                         f-mode target xrl xrrrl)
                                '(|the2| ?slot |of| ?frameadd)))))))))
          (when (eql xrl '|of|)
            (when (consp xrr)
              (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                (when (eql xrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target frameadd)
                                         (let ((multiargs (km-int frameadd :fail-mode fmode :target target :rewritep t)))
                                           (km-int
                                              (vals-to-val (mapcar #'(lambda (multiarg)
                                                                       (cond ((km-structured-list-valp multiarg)
                                                                              (arg2of multiarg))))
                                                                   multiargs)))))
                                     f-mode target xrrl)
                            '(|the2| |of| ?frameadd)))))))))
  ))
(defun h--the3 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrl '|of|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target slot frameadd)
                                             (km-int `(|the3| |of| (|the| ,slot |of| ,frameadd))
                                               :fail-mode fmode
                                               :target target
                                               :rewritep t))
                                         f-mode target xrl xrrrl)
                                '(|the3| ?slot |of| ?frameadd)))))))))
          (when (eql xrl '|of|)
            (when (consp xrr)
              (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                (when (eql xrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target frameadd)
                                         (let ((multiargs (km-int frameadd :fail-mode fmode :target target :rewritep t)))
                                           (km-int
                                              (vals-to-val (mapcar #'(lambda (multiarg)
                                                                       (cond ((km-structured-list-valp multiarg)
                                                                              (arg3of multiarg))))
                                                                   multiargs)))))
                                     f-mode target xrrl)
                            '(|the3| |of| ?frameadd)))))))))
  ))
(defun h--theN (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (when (eql xrrl '|of|)
            (when (consp xrrr)
              (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                (when (eql xrrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target nexpr frameadd)
                                         (let ((n (km-unique-int nexpr :fail-mode 'error))
                                               (multiargs (km-int frameadd :fail-mode fmode :target target :rewritep t)))
                                           (cond ((or (not (integerp n)) (< n 1))
                                                  (report-error 'user-error
                                                                "Doing ~a. ~a should evaluate to a non-negative integer!~%"
                                                                `(|the| ,nexpr |of| ,frameadd) nexpr))
                                                 (t
                                                  (km-int
                                                     (vals-to-val (mapcar #'(lambda (multiarg)
                                                                              (cond ((and
                                                                                      (km-structured-list-valp multiarg)
                                                                                      (< n (length multiarg)))
                                                                                     (elt multiarg n))
                                                                                    ((= n 1) multiarg)))
                                                                          multiargs)))))))
                                     f-mode target xrl xrrrl)
                            '(|theN| ?nexpr |of| ?frameadd))))))))))
  ))
(defun h--theNth (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (when (eql xrrl '|of|)
            (when (consp xrrr)
              (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                (when (eql xrrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target nexpr frameadd)
                                         (let ((n (km-unique-int nexpr :fail-mode 'error))
                                               (vals (km-int frameadd :fail-mode fmode :target target :rewritep t)))
                                           (cond ((or (not (integerp n)) (< n 1))
                                                  (report-error 'user-error
                                                                "Doing ~a. ~a should evaluate to a non-negative integer!~%"
                                                                `(|the| ,nexpr |of| ,frameadd) nexpr))
                                                 ((and (<= n (length vals)) (elt vals (1- n))) (list (elt vals (1- n)))))))
                                     f-mode target xrl xrrrl)
                            '(|theNth| ?nexpr |of| ?frameadd))))))))))
  ))
(defun h--triple (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (when (consp xrrr)
            (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
              (when (eql xrrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target frame-expr slot-expr val-expr)
                                       (declare (ignore _fmode _target))
                                       (let* ((slot
                                               (cond ((comparison-operator slot-expr) slot-expr)
                                                     (t (km-unique-int slot-expr :fail-mode 'error))))
                                              (frame
                                               (cond ((and (comparison-operator slot)
                                                           (minimatch frame-expr '(|the| |?x| |of| |?y|)))
                                                      frame-expr)
                                                     (t (km-unique-int frame-expr :fail-mode 'error))))
                                              (val-expr0 (desource+decomment val-expr))
                                              (val
                                               (cond ((or (constraint-exprp val-expr0) (existential-exprp val-expr0)
                                                          (comparison-operator slot))
                                                      val-expr0)
                                                     (t (vals-to-val (km-int val-expr))))))
                                         `((:|triple| ,frame ,slot ,val))))
                                   f-mode target xrl xrrl xrrrl)
                          '(:|triple| ?frame-expr ?slot-expr ?val-expr)))))))))
  ))
(defun h--showme (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (_fmode _target km-expr) (declare (ignore _fmode _target)) (showme km-expr))
                               f-mode target xrl)
                      '(|showme| ?km-expr))))
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target km-expr file)
                                       (declare (ignore _fmode _target))
                                       (cond ((not (stringp file))
                                              (report-error 'user-error
                                                            "(showme <expr> <filename>): <filename> should be a string!~%"))
                                             (t
                                              (let ((stream (tell file)))
                                                (prog1 (showme km-expr (all-situations) (visible-theories) stream)
                                                       (cond ((streamp stream) (close stream)))
                                                       (km-format t "(Output sent to file ~a)~%" file))))))
                                   f-mode target xrl xrrl)
                          '(|showme| ?km-expr ?file))))))))
  ))
(defun h--explanation (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrl)
        (let ((xrll (first xrl)) (xrlr (rest xrl)))
          (when (eql xrll :|triple|)
            (when (consp xrlr)
              (let ((xrlrl (first xrlr)) (xrlrr (rest xrlr)))
                (when (consp xrlrr)
                  (let ((xrlrrl (first xrlrr)) (xrlrrr (rest xrlrr)))
                    (when (consp xrlrrr)
                      (let ((xrlrrrl (first xrlrrr)) (xrlrrrr (rest xrlrrr)))
                        (when (eql xrlrrrr 'nil)
                          (when (consp xrr)
                            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                              (when (eql xrrr 'nil)
                                (return-from km-handler
                                  (values (funcall #'(lambda (fmode target f0 s v0 explanations)
                                                       (declare (ignore fmode target))
                                                       (let ((f (dereference f0)) (v (dereference v0)))
                                                         (mapc #'(lambda (explanation)
                                                                   (record-explanation-for `(|the| ,s |of| ,f) v
                                                                                           explanation
                                                                     :situation *global-situation*
                                                                     :ignore-clone-cycles t))
                                                               (dereference explanations)))
                                                       '(|t|))
                                                   f-mode target xrlrl xrlrrl xrlrrrl xrrl)
                                          '(|explanation| (:|triple| ?f0 ?s ?v0) ?explanations)))))))))))))))))
  ))
(defun h--an (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (eql xrl '|instance|)
        (when (consp xrr)
          (let ((xrrl (first xrr)) (xrrr (rest xrr)))
            (when (eql xrrl '|of|)
              (when (consp xrrr)
                (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                  (or (when (eql xrrrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target expr)
                                               (km-int `(|an| |instance| |of| ,expr |with|)
                                                 :fail-mode fmode
                                                 :target target
                                                 :rewritep t))
                                           f-mode target xrrrl)
                                  '(|an| |instance| |of| ?expr))))
                      (when (consp xrrrr)
                        (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                          (when (eql xrrrrl '|with|)
                            (return-from km-handler
                              (values (funcall #'(lambda (fmode target expr slotsvals)
                                                   (declare (ignore fmode target))
                                                   (cond ((are-slotsvals slotsvals)
                                                          (let* ((classes (km-int expr))
                                                                 (class (first classes))
                                                                 (classes-in-slotsvals
                                                                  (vals-in (assoc '|instance-of| slotsvals)))
                                                                 (new-slotsvals
                                                                  (cond ((>= (length classes) 2)
                                                                         (update-assoc-list slotsvals
                                                                                            `(|instance-of|
                                                                                              ,(remove-duplicates
                                                                                                (append
                                                                                                 (rest classes)
                                                                                                 classes-in-slotsvals)))))
                                                                        (t slotsvals))))
                                                            (cond ((or classes classes-in-slotsvals)
                                                                   (list (create-instance class new-slotsvals))))))))
                                               f-mode target xrrrl xrrrrr)
                                      '(|an| |instance| |of| ?expr |with| &rest))))))))))))))
  ))
(defun h--in-situation (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr))) 
      (or (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (_fmode _target situation-expr)
                                   (declare (ignore _fmode _target))
                                   (in-situation situation-expr))
                               f-mode target xrl)
                      '(|in-situation| ?situation-expr))))
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (or (when (consp xrrl)
                    (let ((xrrll (first xrrl)) (xrrlr (rest xrrl)))
                      (when (eql xrrll '|the|)
                        (when (consp xrrlr)
                          (let ((xrrlrl (first xrrlr)) (xrrlrr (rest xrrlr)))
                            (when (consp xrrlrr)
                              (let ((xrrlrrl (first xrrlrr)) (xrrlrrr (rest xrrlrr)))
                                (when (eql xrrlrrl '|of|)
                                  (when (consp xrrlrrr)
                                    (let ((xrrlrrrl (first xrrlrrr)) (xrrlrrrr (rest xrrlrrr)))
                                      (when (eql xrrlrrrr 'nil)
                                        (when (eql xrrr 'nil)
                                          (return-from km-handler
                                            (values (funcall #'(lambda (_fmode _target situation slot frame)
                                                                 (declare (ignore _fmode _target))
                                                                 (cond ((and (kb-objectp situation)
                                                                             (isa situation '|Situation|)
                                                                             (already-done frame slot))
                                                                        (remove-constraints (get-vals
                                                                                             frame
                                                                                             slot
                                                                                             :situation
                                                                                             (target-situation
                                                                                              situation
                                                                                              frame
                                                                                              slot))))
                                                                       (t
                                                                        (in-situation situation
                                                                                      `(|the| ,slot |of| ,frame)))))
                                                             f-mode target xrl xrrlrl xrrlrrrl)
                                                    '(|in-situation| ?situation (|the| ?slot |of| ?frame))))))))))))))))
                  (when (eql xrrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target situation-expr km-expr)
                                           (declare (ignore _fmode _target))
                                           (in-situation situation-expr km-expr))
                                       f-mode target xrl xrrl)
                              '(|in-situation| ?situation-expr ?km-expr)))))))))
  ))
(defun h--if (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (when (eql xrrl '|then|)
            (when (consp xrrr)
              (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                (or (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target condition action)
                                             (km-int `(|if| ,condition |then| ,action |else| nil)
                                               :fail-mode fmode
                                               :target target
                                               :rewritep t))
                                         f-mode target xrl xrrrl)
                                '(|if| ?condition |then| ?action))))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrl '|else|)
                          (when (consp xrrrrr)
                            (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                              (when (eql xrrrrrr 'nil)
                                (return-from km-handler
                                  (values (funcall #'(lambda (fmode target condition action altaction)
                                                       (declare (ignore target))
                                                       (let ((test-result (km-int condition)))
                                                         (cond ((not (member test-result '(nil |f| f)))
                                                                (km-int action :fail-mode fmode))
                                                               (t (km-int altaction :fail-mode fmode)))))
                                                   f-mode target xrl xrrrl xrrrrrl)
                                          '(|if| ?condition |then| ?action |else| ?altaction))))))))))))))))
  ))
(defun h--oneof (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target set test)
                                             (declare (ignore fmode target))
                                             (let ((answer
                                                    (find-if #'(lambda (member) (km-int (subst member '|It| test)))
                                                             (km-int set))))
                                               (cond (answer (list answer)))))
                                         f-mode target xrl xrrrl)
                                '(|oneof| ?set |where| ?test)))))))
              (when (eql xrrl '|in|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrl '|where|)
                          (when (consp xrrrrr)
                            (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                              (when (eql xrrrrrr 'nil)
                                (return-from km-handler
                                  (values (funcall #'(lambda (fmode target var set test)
                                                       (declare (ignore fmode target))
                                                       (oneof-where var set test))
                                                   f-mode target xrl xrrrl xrrrrrl)
                                          '(|oneof| ?var |in| ?set |where| ?test))))))))))))))))
  ))
(defun h--theoneof (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (or (when (eql xrrl '|where|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (eql xrrrr 'nil)
                      (return-from km-handler
                        (values (funcall #'(lambda (fmode target set test)
                                             (let ((val
                                                    (km-unique-int `(|forall| ,set |where| ,test |It|)
                                                      :fail-mode fmode
                                                      :target target
                                                      :rewritep t)))
                                               (cond (val (list val)))))
                                         f-mode target xrl xrrrl)
                                '(|theoneof| ?set |where| ?test)))))))
              (when (eql xrrl '|in|)
                (when (consp xrrr)
                  (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                    (when (consp xrrrr)
                      (let ((xrrrrl (first xrrrr)) (xrrrrr (rest xrrrr)))
                        (when (eql xrrrrl '|where|)
                          (when (consp xrrrrr)
                            (let ((xrrrrrl (first xrrrrr)) (xrrrrrr (rest xrrrrr)))
                              (when (eql xrrrrrr 'nil)
                                (return-from km-handler
                                  (values (funcall #'(lambda (fmode target var set test)
                                                       (cond ((not (km-varp var))
                                                              (report-error 'user-error
                                                                            "~a: Second argument should be a variable (e.g., ?x)!~%"
                                                                            `(|theoneof| ,var |in| ,set |where| ,test)))
                                                             (t
                                                              (let ((val
                                                                     (km-unique-int
                                                                        `(|forall| ,var |in| ,set |where| ,test ,var)
                                                                       :fail-mode fmode
                                                                       :target target
                                                                       :rewritep t)))
                                                                (cond (val (list val)))))))
                                                   f-mode target xrl xrrrl xrrrrrl)
                                          '(|theoneof| ?var |in| ?set |where| ?test))))))))))))))))
  ))
(defun h--oneof2 (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrr)
        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
          (when (eql xrrl '|where|)
            (when (consp xrrr)
              (let ((xrrrl (first xrrr)) (xrrrr (rest xrrr)))
                (when (eql xrrrr 'nil)
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target set test)
                                         (declare (ignore fmode target))
                                         (let ((answer
                                                (find-if #'(lambda (member) (km-int (subst member '|It2| test)))
                                                         (km-int set))))
                                           (cond (answer (list answer)))))
                                     f-mode target xrl xrrrl)
                            '(|oneof2| ?set |where| ?test))))))))))
  ))
(defun h--the-class (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (or (when (eql xrr 'nil)
            (return-from km-handler
              (values (funcall #'(lambda (fmode target class)
                                   (declare (ignore fmode target))
                                   (process-unquotes `((|the-class| ,class))))
                               f-mode target xrl)
                      '(|the-class| ?class))))
          (when (consp xrr)
            (let ((xrrl (first xrr)) (xrrr (rest xrr)))
              (when (eql xrrl '|with|)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target class slotsvals)
                                       (declare (ignore fmode target))
                                       (cond ((are-slotsvals slotsvals)
                                              (process-unquotes `((|the-class| ,class |with| ,@slotsvals))))))
                                   f-mode target xrl xrrr)
                          '(|the-class| ?class |with| &rest))))))))
  ))
(defun h--constraints-for (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrl)
        (let ((xrll (first xrl)) (xrlr (rest xrl)))
          (when (eql xrll '|the|)
            (when (consp xrlr)
              (let ((xrlrl (first xrlr)) (xrlrr (rest xrlr)))
                (when (consp xrlrr)
                  (let ((xrlrrl (first xrlrr)) (xrlrrr (rest xrlrr)))
                    (when (eql xrlrrl '|of|)
                      (when (consp xrlrrr)
                        (let ((xrlrrrl (first xrlrrr)) (xrlrrrr (rest xrlrrr)))
                          (when (eql xrlrrrr 'nil)
                            (when (eql xrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (fmode0 target slot frameadd)
                                                     (declare (ignore fmode0 target))
                                                     (let ((frame (km-unique-int frameadd :fail-mode 'error)))
                                                       (mapcar #'quotify (collect-constraints-on-instance frame slot))))
                                                 f-mode target xrlrl xrlrrrl)
                                        '(|constraints-for| (|the| ?slot |of| ?frameadd)))))))))))))))))
  ))
(defun h--rules-for (x xl xr f-mode target)  (block km-handler
    (let ((xrl (first xr)) (xrr (rest xr)))
      (when (consp xrl)
        (let ((xrll (first xrl)) (xrlr (rest xrl)))
          (when (eql xrll '|the|)
            (when (consp xrlr)
              (let ((xrlrl (first xrlr)) (xrlrr (rest xrlr)))
                (when (consp xrlrr)
                  (let ((xrlrrl (first xrlrr)) (xrlrrr (rest xrlrr)))
                    (when (eql xrlrrl '|of|)
                      (when (consp xrlrrr)
                        (let ((xrlrrrl (first xrlrrr)) (xrlrrrr (rest xrlrrr)))
                          (when (eql xrlrrrr 'nil)
                            (when (eql xrr 'nil)
                              (return-from km-handler
                                (values (funcall #'(lambda (fmode0 target slot frameadd)
                                                     (declare (ignore fmode0 target))
                                                     (let ((rules (rules-for slot frameadd)))
                                                       (cond ((null rules) nil)
                                                             ((km-setp rules) (mapcar #'quotify (set-to-list rules)))
                                                             (t (list (quotify rules))))))
                                                 f-mode target xrlrl xrlrrrl)
                                        '(|rules-for| (|the| ?slot |of| ?frameadd)))))))))))))))))
  ))
;--edge
(defun compiled-km-handler-function (f-mode target x)
   #+harlequin-pc-lisp (declare (optimize (debug 0)))     ; patch for Lispworks from Francis Leboutte [1]  
  (block km-handler
    (or (when (consp x)
          (let ((xl (first x)) (xr (rest x))) (or
            (when (eql xl '|the|)
              (when (consp xr) (h--the x xl xr f-mode target)
                ))
            (when (eql xl '|a|)
              (when (consp xr) (h--a x xl xr f-mode target)
                ))
            (when (eql xl '|a-prototype|)
              (when (consp xr) (h--a-prototype x xl xr f-mode target)
                ))
            (when (eql xl '|end-prototype|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target)
                                       (declare (ignore _fmode _target))
                                       (km-setq '*curr-prototype* nil)
                                       (global-situation)
                                       (new-context)
                                       '(|t|))
                                   f-mode target)
                          '(|end-prototype|)))))
            (when (eql xl '|clone|)
              (when (consp xr) (h--clone x xl xr f-mode target)
                ))
            (when (eql xl '|evaluate-paths|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (eval-instances) '(|t|)) f-mode target)
                          '(|evaluate-paths|)))))
            (when (eql xl '|default-fluent-status|)
              (return-from km-handler
                (values (funcall #'(lambda (_fmode _target rest)
                                     (declare (ignore _fmode _target))
                                     (default-fluent-status (first rest)))
                                 f-mode target xr)
                        '(|default-fluent-status| &rest))))
            (when (eql xl '|must-be-a|)
              (when (consp xr) (h--must-be-a x xl xr f-mode target)
                ))
            (when (eql xl '|possible-values|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target _values)
                                           (declare (ignore _fmode _target _values))
                                           (note-are-constraints)
                                           nil)
                                       f-mode target xrl)
                              '(|possible-values| ?values)))))))
            (when (eql xl '|excluded-values|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target _values)
                                           (declare (ignore _fmode _target _values))
                                           (note-are-constraints)
                                           nil)
                                       f-mode target xrl)
                              '(|excluded-values| ?values)))))))
            (when (eql xl '|mustnt-be-a|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target _class)
                                               (declare (ignore _fmode _target _class))
                                               (note-are-constraints)
                                               nil)
                                           f-mode target xrl)
                                  '(|mustnt-be-a| ?class))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrl '|with|)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target _class slotsvals)
                                                   (declare (ignore _fmode _target _class))
                                                   (are-slotsvals slotsvals)
                                                   (note-are-constraints)
                                                   nil)
                                               f-mode target xrl xrrr)
                                      '(|mustnt-be-a| ?class |with| &rest))))))))))
            (when (eql xl '<>)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target _val)
                                           (declare (ignore _fmode _target _val))
                                           (note-are-constraints)
                                           nil)
                                       f-mode target xrl)
                              '(<> ?val)))))))
            (when (eql xl '|no-inheritance|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target))) f-mode target) '(|no-inheritance|)))))
            (when (eql xl '|constraint|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target _expr)
                                           (declare (ignore _fmode _target _expr))
                                           (note-are-constraints)
                                           nil)
                                       f-mode target xrl)
                              '(|constraint| ?expr)))))))
            (when (eql xl '|set-constraint|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target _expr)
                                           (declare (ignore _fmode _target _expr))
                                           (note-are-constraints)
                                           nil)
                                       f-mode target xrl)
                              '(|set-constraint| ?expr)))))))
            (when (eql xl '|set-filter|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target _expr)
                                           (declare (ignore _fmode _target _expr))
                                           (note-are-constraints)
                                           nil)
                                       f-mode target xrl)
                              '(|set-filter| ?expr)))))))
            (when (eql xl '|at-least|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (when (eql xrrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target _n _class)
                                               (declare (ignore _fmode _target _n _class))
                                               (note-are-constraints)
                                               nil)
                                           f-mode target xrl xrrl)
                                  '(|at-least| ?n ?class)))))))))
            (when (eql xl '|at-most|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (when (eql xrrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target _n _class)
                                               (declare (ignore _fmode _target _n _class))
                                               (note-are-constraints)
                                               nil)
                                           f-mode target xrl xrrl)
                                  '(|at-most| ?n ?class)))))))))
            (when (eql xl '|exactly|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (when (eql xrrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target _n _class)
                                               (declare (ignore _fmode _target _n _class))
                                               (note-are-constraints)
                                               nil)
                                           f-mode target xrl xrrl)
                                  '(|exactly| ?n ?class)))))))))
            (when (eql xl '|sanity-check|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (cond (*sanity-checks* (km-int expr :fail-mode fmode :target target)) (t '(|t|))))
                                       f-mode target xrl)
                              '(|sanity-check| ?expr)))))))
            (when (eql xl '|retain-expr|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (let ((instance (fourth target)) (slot (second target)))
                                             (cond ((or (null target)
                                                        (notany #'(lambda (isv-explanation)
                                                                    (let ((explanation (explanation-in isv-explanation)))
                                                                      (equal explanation `(|retain-expr| ,expr))))
                                                                (get-all-explanations instance slot)))
                                                    (km-int expr :fail-mode fmode :target target)))))
                                       f-mode target xrl)
                              '(|retain-expr| ?expr)))))))
            (when (eql xl '|every|)
              (when (consp xr) (h--every x xl xr f-mode target)
                ))
            (when (consp xr) (h--xr x xl xr f-mode target)
              )
            (when (eql xl '|in-theory|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target theory-expr)
                                               (declare (ignore _fmode _target))
                                               (in-theory theory-expr))
                                           f-mode target xrl)
                                  '(|in-theory| ?theory-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target theory-expr km-expr)
                                                   (declare (ignore _fmode _target))
                                                   (in-theory theory-expr km-expr))
                                               f-mode target xrl xrrl)
                                      '(|in-theory| ?theory-expr ?km-expr))))))))))
            (when (eql xl '|hide-theory|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target theory-expr)
                                           (declare (ignore _fmode _target))
                                           (mapc #'hide-theory (km-int theory-expr))
                                           (cond ((visible-theories)) (t '(|t|))))
                                       f-mode target xrl)
                              '(|hide-theory| ?theory-expr)))))))
            (when (eql xl '|see-theory|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target theory-expr)
                                           (declare (ignore _fmode _target))
                                           (mapc #'see-theory (km-int theory-expr))
                                           (visible-theories))
                                       f-mode target xrl)
                              '(|see-theory| ?theory-expr)))))))
            (when (eql xl '|end-theory|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (in-situation *global-situation*))
                                   f-mode target)
                          '(|end-theory|)))))
            (when (eql xl '|visible-theories|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (visible-theories)) f-mode target)
                          '(|visible-theories|)))))
            (when (eql xl '|in-situation|)
              (when (consp xr) (h--in-situation x xl xr f-mode target)
                ))
            (when (eql xl '|end-situation|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (in-situation *global-situation*))
                                   f-mode target)
                          '(|end-situation|)))))
            (when (eql xl '|global-situation|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (in-situation *global-situation*))
                                   f-mode target)
                          '(|global-situation|)))))
            (when (eql xl '|new-situation|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (new-situation)) f-mode target)
                          '(|new-situation|)))))
            (when (eql xl '|do|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target action-expr)
                                               (declare (ignore _fmode _target))
                                               (list (do-action action-expr)))
                                           f-mode target xrl)
                                  '(|do| ?action-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target action-expr next-situation)
                                                   (declare (ignore _fmode _target))
                                                   (cond ((not (instance-of next-situation '|Situation|))
                                                          (report-error 'user-error
                                                                        "(do ~a ~a): ~a should be an instance of Situation, but isn't!~%"
                                                                        action-expr next-situation next-situation))
                                                         (t (list (do-action action-expr :next-situation next-situation)))))
                                               f-mode target xrl xrrl)
                                      '(|do| ?action-expr ?next-situation))))))))))
            (when (eql xl '|do-and-next|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target action-expr)
                                               (declare (ignore _fmode _target))
                                               (list (do-action action-expr :change-to-next-situation t)))
                                           f-mode target xrl)
                                  '(|do-and-next| ?action-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target action-expr next-situation)
                                                   (declare (ignore _fmode _target))
                                                   (cond ((not (instance-of next-situation '|Situation|))
                                                          (report-error 'user-error
                                                                        "(do ~a ~a): ~a should be an instance of Situation, but isn't!~%"
                                                                        action-expr next-situation next-situation))
                                                         (t
                                                          (list (do-action action-expr
                                                                  :next-situation next-situation
                                                                  :change-to-next-situation t)))))
                                               f-mode target xrl xrrl)
                                      '(|do-and-next| ?action-expr ?next-situation))))))))))
            (when (eql xl '|try-do|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target action-expr)
                                               (declare (ignore _fmode _target))
                                               (list (do-action action-expr :test-or-assert-pcs 'test)))
                                           f-mode target xrl)
                                  '(|try-do| ?action-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target action-expr next-situation)
                                                   (declare (ignore _fmode _target))
                                                   (cond ((not (instance-of next-situation '|Situation|))
                                                          (report-error 'user-error
                                                                        "(do ~a ~a): ~a should be an instance of Situation, but isn't!~%"
                                                                        action-expr next-situation next-situation))
                                                         (t
                                                          (list (do-action action-expr
                                                                  :next-situation next-situation
                                                                  :test-or-assert-pcs 'test)))))
                                               f-mode target xrl xrrl)
                                      '(|try-do| ?action-expr ?next-situation))))))))))
            (when (eql xl '|try-do-and-next|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target action-expr)
                                               (declare (ignore _fmode _target))
                                               (list (do-action action-expr :change-to-next-situation t :test-or-assert-pcs 'test)))
                                           f-mode target xrl)
                                  '(|try-do-and-next| ?action-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target action-expr next-situation)
                                                   (declare (ignore _fmode _target))
                                                   (cond ((not (instance-of next-situation '|Situation|))
                                                          (report-error 'user-error
                                                                        "(do ~a ~a): ~a should be an instance of Situation, but isn't!~%"
                                                                        action-expr next-situation next-situation))
                                                         (t
                                                          (list (do-action action-expr
                                                                  :next-situation next-situation
                                                                  :change-to-next-situation t
                                                                  :test-or-assert-pcs 'test)))))
                                               f-mode target xrl xrrl)
                                      '(|try-do-and-next| ?action-expr ?next-situation))))))))))
            (when (eql xl '|do-concurrently|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target action-expr)
                                               (declare (ignore _fmode _target))
                                               (let* ((actions (km-int action-expr))
                                                      (next-situation (km-unique-int `(|do| ,(first actions)))))
                                                 (mapc #'(lambda (action) (km-int `(|do| ,action ,next-situation))) (rest actions))
                                                 (list next-situation)))
                                           f-mode target xrl)
                                  '(|do-concurrently| ?action-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target action-expr next-situation)
                                                   (declare (ignore _fmode _target))
                                                   (cond ((not (instance-of next-situation '|Situation|))
                                                          (report-error 'user-error
                                                                        "(do ~a ~a): ~a should be an instance of Situation, but isn't!~%"
                                                                        action-expr next-situation next-situation))
                                                         (t
                                                          (let ((actions (km-int action-expr)))
                                                            (mapc #'(lambda (action) (km-int `(|do| ,action ,next-situation))) actions)
                                                            (list next-situation)))))
                                               f-mode target xrl xrrl)
                                      '(|do-concurrently| ?action-expr ?next-situation))))))))))
            (when (eql xl '|do-concurrently-and-next|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (or (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (_fmode _target action-expr)
                                               (declare (ignore _fmode _target))
                                               (let* ((actions (km-int action-expr))
                                                      (next-situation (km-unique-int `(|do| ,(first actions)))))
                                                 (mapc #'(lambda (action) (km-int `(|do| ,action ,next-situation))) (rest actions))
                                                 (in-situation next-situation)
                                                 (list next-situation)))
                                           f-mode target xrl)
                                  '(|do-concurrently-and-next| ?action-expr))))
                      (when (consp xrr)
                        (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                          (when (eql xrrr 'nil)
                            (return-from km-handler
                              (values (funcall #'(lambda (_fmode _target action-expr next-situation)
                                                   (declare (ignore _fmode _target))
                                                   (cond ((not (instance-of next-situation '|Situation|))
                                                          (report-error 'user-error
                                                                        "(do ~a ~a): ~a should be an instance of Situation, but isn't!~%"
                                                                        action-expr next-situation next-situation))
                                                         (t
                                                          (let ((actions (km-int action-expr)))
                                                            (mapc #'(lambda (action) (km-int `(|do| ,action ,next-situation))) actions)
                                                            (in-situation next-situation)
                                                            (list next-situation)))))
                                               f-mode target xrl xrrl)
                                      '(|do-concurrently-and-next| ?action-expr ?next-situation))))))))))
            (when (eql xl '|do-script|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target script)
                                           (km-int `(|forall| (|the| |actions| |of| ,script) (|do-and-next| |It|))
                                             :fail-mode fmode
                                             :target target
                                             :rewritep t))
                                       f-mode target xrl)
                              '(|do-script| ?script)))))))
            (when (eql xl '|do-plan|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target plan-instance-expr)
                                           (declare (ignore _fmode _target))
                                           (let ((plan-instance (km-unique plan-instance-expr))) (do-plan plan-instance)))
                                       f-mode target xrl)
                              '(|do-plan| ?plan-instance-expr)))))))
            (when (eql xl '|assert|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target triple-expr)
                                           (declare (ignore _fmode _target))
                                           (let ((triple (km-unique-int triple-expr)))
                                             (cond ((not (km-triplep triple))
                                                    (report-error 'user-error
                                                                  "(assert ~a): ~a should evaluate to a triple! (evaluated to ~a instead)!~%"
                                                                  triple-expr triple))
                                                   (t
                                                    (km-int `(,(arg1of triple) |has| (,(arg2of triple) ,(val-to-vals (arg3of triple))))
                                                      :fail-mode 'error)))))
                                       f-mode target xrl)
                              '(|assert| ?triple-expr)))))))
            (when (eql xl '|is-true|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target triple-expr)
                                           (declare (ignore _fmode _target))
                                           (let* ((triple (km-unique-int triple-expr)))
                                             (cond ((not (km-triplep triple))
                                                    (report-error 'user-error
                                                                  "(is-true ~a): ~a should evaluate to a triple! (evaluated to ~a instead)!~%"
                                                                  triple-expr triple))
                                                   ((comparison-operator (arg2of triple))
                                                    (km-int `(,(second triple) ,(third triple) ,(fourth triple))))
                                                   (t
                                                    (let ((frame (km-unique-int (second triple) :fail-mode 'error))
                                                          (slot (km-unique-int (third triple) :fail-mode 'error))
                                                          (value (fourth triple)))
                                                      (cond ((null value) '(|t|))
                                                            ((km-int `(,frame |is| '(|a| |Thing| |with| (,slot (,value))))))))))))
                                       f-mode target xrl)
                              '(|is-true| ?triple-expr)))))))
            (when (eql xl '|all-true|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target triples-expr)
                                           (declare (ignore _fmode _target))
                                           (let ((triples (km-int triples-expr)))
                                             (cond ((every #'(lambda (triple) (km-int `(|is-true| ,triple))) triples) '(|t|)))))
                                       f-mode target xrl)
                              '(|all-true| ?triples-expr)))))))
            (when (eql xl '|some-true|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target triples-expr)
                                           (declare (ignore _fmode _target))
                                           (let ((triples (km-int triples-expr)))
                                             (cond ((some #'(lambda (triple) (km-int `(|is-true| ,triple))) triples) '(|t|)))))
                                       f-mode target xrl)
                              '(|some-true| ?triples-expr)))))))
            (when (eql xl '|next-situation|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target)
                                       (declare (ignore _fmode _target))
                                       (cond ((am-in-local-situation) (list (do-action nil :change-to-next-situation t)))
                                             (t (report-error 'user-error "Can only do (next-situation) from within a situation!~%"))))
                                   f-mode target)
                          '(|next-situation|)))))
            (when (eql xl '|curr-situation|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (list (curr-situation))) f-mode target)
                          '(|curr-situation|)))))
            (when (eql xl '|ignore-result|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr) (declare (ignore fmode target)) (km-int expr) nil) f-mode target
                                       xrl)
                              '(|ignore-result| ?expr)))))))
            (when (eql xl '|ignore|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr) (declare (ignore fmode target expr)) nil) f-mode target xrl)
                              '(|ignore| ?expr)))))))
            (when (eql xl '|in-every-situation|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (when (eql xrrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target situation-class km-expr)
                                               (cond ((not (is-subclass-of situation-class '|Situation|))
                                                      (report-error 'user-error
                                                                    "~a:~%   Can't do this! (~a is not a subclass of Situation!)~%"
                                                                    `(|in-every-situation| ,situation-class ,km-expr) situation-class))
                                                     (t
                                                      (let ((modified-expr
                                                             (sublis '((|TheSituation| unquote |Self|) (|Self| . |SubSelf|)) km-expr)))
                                                        (km-int
                                                           `(|in-situation| ,*global-situation*
                                                             (|every| ,situation-class |has| (|assertions| (',modified-expr))))
                                                          :fail-mode fmode
                                                          :target target
                                                          :rewritep t)))))
                                           f-mode target xrl xrrl)
                                  '(|in-every-situation| ?situation-class ?expr)))))))))
            (when (eql xl '|new-context|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) (clear-obj-stack) '(|t|)) f-mode
                                   target)
                          '(|new-context|)))))
            (when (eql xl '|thelast|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target frame)
                                           (declare (ignore _fmode _target))
                                           (let ((last-instance (search-stack frame))) (cond (last-instance (list last-instance)))))
                                       f-mode target xrl)
                              '(|thelast| ?frame)))))))
            (when (eql xl '|the+|)
              (when (consp xr) (h--the+ x xl xr f-mode target)
                ))
            (when (eql xl '|a+|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target rest) (km-int `(|the+| ,@rest) :fail-mode fmode :target target :rewritep t))
                                 f-mode target xr)
                        '(|a+| &rest))))
            (when (eql xl '|if|)
              (when (consp xr) (h--if x xl xr f-mode target)
                ))
            (when (eql xl '|not|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target x) (declare (ignore _fmode _target)) (cond ((not (km-int x)) '(|t|))))
                                       f-mode target xrl)
                              '(|not| ?x)))))))
            (when (eql xl '|numberp|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target x)
                                           (declare (ignore _fmode _target))
                                           (cond ((numberp (km-unique-int x)) '(|t|))))
                                       f-mode target xrl)
                              '(|numberp| ?x)))))))
            (when (eql xl '|allof|)
              (when (consp xr) (h--allof x xl xr f-mode target)
                ))
            (when (eql xl '|oneof|)
              (when (consp xr) (h--oneof x xl xr f-mode target)
                ))
            (when (eql xl '|theoneof|)
              (when (consp xr) (h--theoneof x xl xr f-mode target)
                ))
            (when (eql xl '|forall|)
              (when (consp xr) (h--forall x xl xr f-mode target)
                ))
            (when (eql xl '|forall-seq|)
              (when (consp xr) (h--forall-seq x xl xr f-mode target)
                ))
            (when (eql xl '|forall-bag|)
              (when (consp xr) (h--forall-bag x xl xr f-mode target)
                ))
            (when (eql xl '|forall-seq2|)
              (when (consp xr) (h--forall-seq2 x xl xr f-mode target)
                ))
            (when (eql xl '|forall-bag2|)
              (when (consp xr) (h--forall-bag2 x xl xr f-mode target)
                ))
            (when (eql xl '|allof2|)
              (when (consp xr) (h--allof2 x xl xr f-mode target)
                ))
            (when (eql xl '|oneof2|)
              (when (consp xr) (h--oneof2 x xl xr f-mode target)
                ))
            (when (eql xl '|forall2|)
              (when (consp xr) (h--forall2 x xl xr f-mode target)
                ))
            (when (eql xl '|theoneof2|)
              (when (consp xr) (h--theoneof2 x xl xr f-mode target)
                ))
            (when (eql xl 'function)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target lispcode)
                                           (declare (ignore _fmode _target))
                                           (let* ((answer0 (funcall (eval (list 'function lispcode)))) (answer (listify answer0)))
                                             (cond ((every #'fully-evaluatedp answer) answer)
                                                   (t
                                                    (report-error 'user-error "In call to external Lisp procedure
~a
Lisp procedure should return a list of fully evaluated KM objects (e.g., 
instances, or :seq/:bag/:pair of instances), but instead returned:
~a~%" lispcode answer0)))))
                                       f-mode target xrl)
                              '#'?lispcode))))))
            (when (eql xl '|the1|)
              (when (consp xr) (h--the1 x xl xr f-mode target)
                ))
            (when (eql xl '|the2|)
              (when (consp xr) (h--the2 x xl xr f-mode target)
                ))
            (when (eql xl '|the3|)
              (when (consp xr) (h--the3 x xl xr f-mode target)
                ))
            (when (eql xl '|theN|)
              (when (consp xr) (h--theN x xl xr f-mode target)
                ))
            (when (eql xl '|theNth|)
              (when (consp xr) (h--theNth x xl xr f-mode target)
                ))
            (when (eql xl :|set|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target exprs)
                                     (declare (ignore fmode))
                                     (my-mapcan #'(lambda (expr) (km-int expr :target target)) exprs))
                                 f-mode target xr)
                        '(:|set| &rest))))
            (when (eql xl :|seq|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target exprs)
                                     (declare (ignore target fmode))
                                     (let ((sequence (mapcar #'(lambda (expr) (vals-to-val (km-int expr))) exprs)))
                                       (cond (sequence `((:|seq| ,@sequence))))))
                                 f-mode target xr)
                        '(:|seq| &rest))))
            (when (eql xl :|bag|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target exprs)
                                     (declare (ignore target fmode))
                                     (let ((bag (mapcar #'(lambda (expr) (vals-to-val (km-int expr))) exprs)))
                                       (cond (bag `((:|bag| ,@bag))))))
                                 f-mode target xr)
                        '(:|bag| &rest))))
            (when (eql xl :|function|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target exprs)
                                     (declare (ignore target fmode))
                                     (let ((sequence (mapcar #'(lambda (expr) (vals-to-val (km-int expr))) exprs)))
                                       (cond (sequence `((:|function| ,@sequence))))))
                                 f-mode target xr)
                        '(:|function| &rest))))
            (when (eql xl :|pair|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target exprs)
                                     (declare (ignore target fmode))
                                     (cond ((not (pairp exprs))
                                            (report-error 'user-error "~a: A pair should have exactly two elements!~%"
                                                          `(:|pair| ,@exprs)))
                                           (t
                                            (let ((sequence (mapcar #'(lambda (expr) (vals-to-val (km-int expr))) exprs)))
                                              (cond (sequence `((:|pair| ,@sequence))))))))
                                 f-mode target xr)
                        '(:|pair| &rest))))
            (when (eql xl :|triple|)
              (when (consp xr) (h--triple x xl xr f-mode target)
                ))
            (when (eql xl :|args|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target exprs)
                                     (declare (ignore fmode target))
                                     (let ((sequence (mapcar #'(lambda (expr) (vals-to-val (km-int expr))) exprs)))
                                       (cond (sequence `((:|args| ,@sequence))))))
                                 f-mode target xr)
                        '(:|args| &rest))))
            (when (eql xl '|showme|)
              (when (consp xr) (h--showme x xl xr f-mode target)
                ))
            (when (eql xl '|showme-all|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target km-expr) (declare (ignore _fmode _target)) (showme-all km-expr))
                                       f-mode target xrl)
                              '(|showme-all| ?km-expr)))))))
            (when (eql xl '|evaluate-all|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target km-expr) (declare (ignore _fmode _target)) (evaluate-all km-expr))
                                       f-mode target xrl)
                              '(|evaluate-all| ?km-expr)))))))
            (when (eql xl '|showme-here|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target km-expr)
                                           (declare (ignore _fmode _target))
                                           (showme km-expr (list (curr-situation)) (visible-theories)))
                                       f-mode target xrl)
                              '(|showme-here| ?km-expr)))))))
            (when (eql xl '|the-class|)
              (when (consp xr) (h--the-class x xl xr f-mode target)
                ))
            (when (eql xl '|constraints-for|)
              (when (consp xr) (h--constraints-for x xl xr f-mode target)
                ))
            (when (eql xl '|rules-for|)
              (when (consp xr) (h--rules-for x xl xr f-mode target)
                ))
            (when (eql xl '|why|)
              (or (when (eql xr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (why)) f-mode target) '(|why|))))
                  (when (consp xr)
                    (let ((xrl (first xr)) (xrr (rest xr)))
                      (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target triple)
                                               (declare (ignore fmode target))
                                               (cond ((not (km-triplep triple))
                                                      (report-error 'user-error
                                                                    "Bad argument to (why ...)! Should be of form (why (:triple <f> <s> <v>))!"))
                                                     (t (why triple))))
                                           f-mode target xrl)
                                  '(|why| ?triple))))))))
            (when (eql xl '|justify|)
              (or (when (eql xr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (justify)) f-mode target)
                              '(|justify|))))
                  (when (consp xr)
                    (let ((xrl (first xr)) (xrr (rest xr)))
                      (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target triple) (declare (ignore fmode target)) (justify triple)) f-mode
                                           target xrl)
                                  '(|justify| ?triple))))))))
            (when (eql xl '|get-justification|)
              (or (when (eql xr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target)
                                           (declare (ignore fmode target))
                                           (list (concat-list (insert-delimeter (get-justification :format 'ascii) *newline-str*))))
                                       f-mode target)
                              '(|get-justification|))))
                  (when (consp xr)
                    (let ((xrl (first xr)) (xrr (rest xr)))
                      (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target triple)
                                               (declare (ignore fmode target))
                                               (list (concat-list (insert-delimeter (get-justification :triple triple :format 'ascii)
                                                                                    *newline-str*))))
                                           f-mode target xrl)
                                  '(|get-justification| ?triple))))))))
            (when (eql xl '|explanation|)
              (when (consp xr) (h--explanation x xl xr f-mode target)
                ))
            (when (eql xl '|explained-by|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (when (eql xrrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target instance expr)
                                               (declare (ignore fmode target))
                                               (explained-by instance expr))
                                           f-mode target xrl xrrl)
                                  '(|explained-by| ?instance ?expr)))))))))
            (when (eql xl '|comment|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (return-from km-handler
                    (values (funcall #'(lambda (fmode target comment-tag data)
                                         (declare (ignore fmode target))
                                         (comment comment-tag data))
                                     f-mode target xrl xrr)
                            '(|comment| ?comment-tag &rest))))))
            (when (eql xl '|show-comment|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target comment-tag) (declare (ignore fmode target)) (show-comment comment-tag))
                                       f-mode target xrl)
                              '(|show-comment| ?comment-tag)))))))
            (when (eql xl 'quote)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (declare (ignore fmode target))
                                           (let ((processed-expr (process-unquotes expr)))
                                             (cond (processed-expr (list (list 'quote processed-expr))))))
                                       f-mode target xrl)
                              ''?expr))))))
            (when (eql xl 'unquote)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (declare (ignore fmode target))
                                           (report-error 'user-error
                                                         "Doing #,~a: You can't unquote something without it first being quoted!~%"
                                                         expr))
                                       f-mode target xrl)
                              '(unquote ?expr)))))))
            (when (eql xl '|delete|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target km-expr)
                                           (mapc #'delete-frame (km-int km-expr :fail-mode fmode :target target :rewritep t))
                                           '(|t|))
                                       f-mode target xrl)
                              '(|delete| ?km-expr)))))))
            (when (eql xl '|evaluate|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (let ((quoted-exprs (km-int expr :fail-mode fmode :target target :rewritep t)))
                                             (remove nil
                                                     (my-mapcan #'(lambda (quoted-expr)
                                                                    (cond ((member quoted-expr '(|f| f)) nil)
                                                                          ((and (pairp quoted-expr) (eq (first quoted-expr) 'quote))
                                                                           (km-int (second quoted-expr) :fail-mode fmode))
                                                                          (t
                                                                           (report-error 'user-error
                                                                                         "(evaluate ~a)~%evaluate should be given a quoted expression to evaluate!~%"
                                                                                         quoted-expr))))
                                                                quoted-exprs))))
                                       f-mode target xrl)
                              '(|evaluate| ?expr)))))))
            (when (eql xl '|exists|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target frame)
                                           (report-error 'user-warning
                                                         "(exists ~a): (exists <expr>) has been renamed (has-value <expr>) in KM 1.4.~%       Please update your KB! Continuing...~%"
                                                         frame)
                                           (km-int `(|has-value| ,frame) :fail-mode fmode :target target :rewritep t))
                                       f-mode target xrl)
                              '(|exists| ?frame)))))))
            (when (eql xl '|has-value|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target frame)
                                           (declare (ignore _fmode _target))
                                           (cond ((km-int frame) '(|t|))))
                                       f-mode target xrl)
                              '(|has-value| ?frame)))))))
            (when (eql xl '|print|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target expr)
                                           (declare (ignore _fmode _target))
                                           (let ((vals (km-int expr))) (km-format t "~a~%" vals) vals))
                                       f-mode target xrl)
                              '(|print| ?expr)))))))
            (when (eql xl '|format|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (return-from km-handler
                        (values (funcall #'(lambda (_fmode _target flag string arguments)
                                             (declare (ignore _fmode _target))
                                             (cond ((eq flag '|t|)
                                                    (apply #'format `(t ,string ,@(mapcar #'(lambda (arg) (km-int arg)) arguments)))
                                                    '(|t|))
                                                   ((member flag '(|nil| nil))
                                                    (list (apply #'format
                                                                 `(nil ,string ,@(mapcar #'(lambda (arg) (km-int arg)) arguments)))))
                                                   (t
                                                    (report-error 'user-error "~a: Second argument must be `t' or `nil', not `~a'!~%"
                                                                  `(|format| ,flag ,string ,@arguments) flag))))
                                         f-mode target xrl xrrl xrrr)
                                '(|format| ?flag ?string &rest))))))))
            (when (eql xl '|km-format|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (consp xrr)
                    (let ((xrrl (first xrr)) (xrrr (rest xrr)))
                      (return-from km-handler
                        (values (funcall #'(lambda (_fmode _target flag string arguments)
                                             (declare (ignore _fmode _target))
                                             (cond ((eq flag '|t|)
                                                    (apply #'km-format `(t ,string ,@(mapcar #'(lambda (arg) (km-int arg)) arguments)))
                                                    '(|t|))
                                                   ((member flag '(|nil| nil))
                                                    (list (apply #'km-format
                                                                 `(nil ,string ,@(mapcar #'(lambda (arg) (km-int arg)) arguments)))))
                                                   (t
                                                    (report-error 'user-error "~a: Second argument must be `t' or `nil', not `~a'!~%"
                                                                  `(|km-format| ,flag ,string ,@arguments) flag))))
                                         f-mode target xrl xrrl xrrr)
                                '(|km-format| ?flag ?string &rest))))))))
            (when (eql xl '|andify|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (list (cons ':|seq| (andify (km-int expr :fail-mode fmode :target target :rewritep t)))))
                                       f-mode target xrl)
                              '(|andify| ?expr)))))))
            (when (eql xl '|make-sentence|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target expr)
                                           (declare (ignore _fmode _target))
                                           (let ((text (km-int expr)))
                                             (make-comment "anglifying ~a" text)
                                             (list (make-sentence text))))
                                       f-mode target xrl)
                              '(|make-sentence| ?expr)))))))
            (when (eql xl '|make-phrase|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (_fmode _target expr)
                                           (declare (ignore _fmode _target))
                                           (let ((text (km-int expr))) (make-comment "anglifying ~a" text) (list (make-phrase text))))
                                       f-mode target xrl)
                              '(|make-phrase| ?expr)))))))
            (when (eql xl '|pluralize|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (declare (ignore fmode target))
                                           (report-error 'user-error
                                                         "(pluralize ~a): pluralize is no longer defined in KM1.4 - use \"-s\" suffix instead!~%"
                                                         expr))
                                       f-mode target xrl)
                              '(|pluralize| ?expr)))))))
            (when (eql xl '|spy|)
              (or (when (consp xr)
                    (let ((xrl (first xr)) (xrr (rest xr)))
                      (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target expr) (declare (ignore fmode target)) (spy expr)) f-mode target xrl)
                                  '(|spy| ?expr))))))
                  (when (eql xr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (spy)) f-mode target) '(|spy|))))))
            (when (eql xl '|unspy|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (unspy)) f-mode target) '(|unspy|)))))
            (when (eql xl '|profile|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (declare (ignore fmode target))
                                           (let ((*profiling* t))
                                             (profile-reset)
                                             (let ((answer (km-int expr))) (km-format t "~a~%" answer) (profile-report) answer)))
                                       f-mode target xrl)
                              '(|profile| ?expr)))))))
            (when (eql xl '|profile-report|)
              (or (when (eql xr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (profile-report) '(|t|)) f-mode target)
                              '(|profile-report|))))
                  (when (consp xr)
                    (let ((xrl (first xr)) (xrr (rest xr)))
                      (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target n) (declare (ignore fmode target)) (profile-report n) '(|t|)) f-mode
                                           target xrl)
                                  '(|profile-report| ?n))))))))
            (when (eql xl '|taxonomy|)
              (return-from km-handler
                (values (funcall #'(lambda (fmode target args)
                                     (declare (ignore fmode target))
                                     (cond ((null args) (taxonomy))
                                           ((singletonp args) (taxonomy (km-unique (first args))))
                                           ((pairp args) (taxonomy (km-unique (first args)) (km-unique (second args))))
                                           (t
                                            (report-error 'user-error
                                                          "Too many arguments to the taxonomy function! Format is (taxonomy <top-node> <relation-to-descend>)~%"))))
                                 f-mode target xr)
                        '(|taxonomy| &rest))))
            (when (eql xl '|checkpoint|)
              (or (when (eql xr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (set-checkpoint) '(|t|)) f-mode target)
                              '(|checkpoint|))))
                  (when (consp xr)
                    (let ((xrl (first xr)) (xrr (rest xr)))
                      (when (eql xrr 'nil)
                        (return-from km-handler
                          (values (funcall #'(lambda (fmode target checkpoint-id)
                                               (declare (ignore fmode target))
                                               (cond ((null checkpoint-id)
                                                      (report-error 'user-error
                                                                    "(checkpoint ~a): Argument to checkpoint can't be NIL!~%"
                                                                    checkpoint-id))
                                                     (t (set-checkpoint checkpoint-id) '(|t|))))
                                           f-mode target xrl)
                                  '(|checkpoint| ?checkpoint-id))))))))
            (when (eql xl '|undo|)
              (when (eql xr 'nil)
                (return-from km-handler
                  (values (funcall #'(lambda (fmode target) (declare (ignore fmode target)) (cond ((undo) '(|t|)))) f-mode target)
                          '(|undo|)))))
            (when (eql xl '|an|)
              (when (consp xr) (h--an x xl xr f-mode target)
                ))
            (when (eql xl '|reverse|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target seq-expr)
                                           (let ((seq (km-unique-int seq-expr :fail-mode fmode :target target :rewritep t)))
                                             (cond ((null seq) nil)
                                                   ((km-seqp seq) (list (cons ':|seq| (reverse (rest seq)))))
                                                   (t
                                                    (report-error 'user-error
                                                                  "Attempting to reverse a non-sequence ~a!~%[Sequences should be of the form (:seq <e1> ... <en>)]~%"
                                                                  seq-expr)))))
                                       f-mode target xrl)
                              '(|reverse| ?seq-expr)))))))
            (when (eql xl :|default|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (declare (ignore fmode target expr))
                                           (km-setq '*are-some-defaults* t)
                                           nil)
                                       f-mode target xrl)
                              '(:|default| ?expr)))))))
            (when (eql xl '|sometimes|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr) (km-int expr :fail-mode fmode :target target :rewritep t)) f-mode
                                       target xrl)
                              '(|sometimes| ?expr)))))))
            (when (eql xl '|anonymous-instancep|)
              (when (consp xr)
                (let ((xrl (first xr)) (xrr (rest xr)))
                  (when (eql xrr 'nil)
                    (return-from km-handler
                      (values (funcall #'(lambda (fmode target expr)
                                           (declare (ignore fmode target))
                                           (cond ((anonymous-instancep (km-unique-int expr :fail-mode 'error)) '(|t|))))
                                       f-mode target xrl)
                              '(|anonymous-instancep| ?expr)))))))
            ;-or-end
            )))
        (when (eql x '|nil|)
          (return-from km-handler
            (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) nil) f-mode target) '|nil|)))
        (when (eql x 'nil)
          (return-from km-handler (values (funcall #'(lambda (_fmode _target) (declare (ignore _fmode _target)) nil) f-mode target) 'nil)))
        (return-from km-handler
          (values (funcall #'(lambda (fmode0 target path)
                               (declare (ignore target))
                               (cond ((atom path) (cond ((no-reserved-keywords (list path)) (list path))))
                                     ((not (listp path)) (report-error 'program-error "Failed to find km handler for ~a!~%" path))
                                     ((singletonp path) (km-int (first path) :fail-mode fmode0))
                                     ((and (triplep path) (assoc (second path) *user-defined-infix-operators*))
                                      (let ((infix-implementation-fn (second (assoc (second path) *user-defined-infix-operators*))))
                                        (cond ((not (functionp infix-implementation-fn))
                                               (report-error 'user-error "
The specified implementation of infix operator ~a is not a Lisp function! (missing \"#'\" prefix?)
The specified implementation was: ~a~%" (second path) infix-implementation-fn))
                                              (t
                                               (let* ((x (vals-to-val (km-int (first path))))
                                                      (y (vals-to-val (km-int (third path))))
                                                      (answer0 (apply infix-implementation-fn (list x y)))
                                                      (answer (listify answer0)))
                                                 (cond ((every #'fully-evaluatedp answer) answer)
                                                       (t
                                                        (report-error 'user-error "In call to external Lisp procedure
(~a ~a ~a)
Lisp procedure should return one/a list of fully evaluated KM objects (e.g., 
instances, or :seq/:bag/:pair of instances), but instead returned:
   ~a~%" infix-implementation-fn x y answer0))))))))
                                     ((not *linear-paths*)
                                      (report-error 'user-error "KM Syntax error: ~a is not a valid KM expression~%" path))
                                     ((not (no-reserved-keywords path)) nil)
                                     ((oddp (length path))
                                      (cond ((structured-slotp (last-el (butlast path)))
                                             (follow-multidepth-path (km-int (butlast (butlast path)) :fail-mode fmode0)
                                                                     (last-el (butlast path)) (last-el path)
                                               :fail-mode fmode0))
                                            (t (vals-in-class (km-int (butlast path) :fail-mode fmode0) (last-el path)))))
                                     ((evenp (length path))
                                      (let* ((frameadd (cond ((pairp path) (first path)) (t (butlast path)))) (slot0 (last-el path)))
                                        (cond ((structured-slotp slot0)
                                               (follow-multidepth-path (km-int frameadd :fail-mode fmode0) slot0 '* :fail-mode fmode0))
                                              (t
                                               (let* ((slot (cond ((pathp slot0) (km-unique-int slot0 :fail-mode 'error)) (t slot0)))
                                                      (fmode (cond ((built-in-aggregation-slot slot) 'fail) (t fmode0)))
                                                      (frames (km-int frameadd :fail-mode fmode)))
                                                 (cond ((not (equal frames (val-to-vals frameadd)))
                                                        (km-int `(,(vals-to-val frames) ,slot) :fail-mode fmode))
                                                       (t (km-multi-slotvals frames slot :fail-mode fmode))))))))))
                           f-mode target x)
                  '?path)))))
(trace compiled-km-handler-function) ;not sure how compiled&if would see a trace

(setq *km-handler-function* #'compiled-km-handler-function)

;;; This file was generated by (write-compiled-handlers) in compiler.lisp.
;;; This partially flattens the code assigned to *km-handler-list*, which results in
;;; 10%-30% faster execution (10%-30%) at run-time. Loading of this file is optional, 
;;; KM will be slower if it's not loaded. For the legible, unflattened source of this
;;; flattened code, see the file interpreter.lisp.

;;; ==================== END OF MACHINE-GENERATED FILE ====================

